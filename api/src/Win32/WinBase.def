<* +M2EXTENSIONS  *>
<* ALIGNMENT="8" *>
<* ENUMSIZE="4" *>
<* SETSIZE="4" *>

DEFINITION MODULE ["StdCall"] WinBase;

(************************************************************************
*                                                                       *
*   Winbase -- This module defines the 32-Bit Windows Base APIs         *
*                                                                       *
************************************************************************)

IMPORT SYSTEM;

FROM WinDef IMPORT BOOL, UINT, WCHAR, LONG, ULONG, INT8, CARD8,
            BYTE, WORD, DWORD, PVOID, LPCVOID, PBYTE, PCARD8, PDWORD, PCDWORD,
            PSTR, PWSTR, PCSTR, PCWSTR, RESOURCESTRA, RESOURCESTRW,
            ATOM, ATOMSTR,
            HANDLE, HWND, HGLOBAL, HLOCAL, HMODULE, PHANDLE,
            HRSRC, HFILE, MAX_PATH;

FROM WinNT IMPORT  LARGE_INTEGER,
                   PLARGE_INTEGER,
                   ULARGE_INTEGER,

                   STATUS_WAIT_0,
                   STATUS_ABANDONED_WAIT_0,
                   STATUS_TIMEOUT,
                   STATUS_USER_APC,
                   STATUS_PENDING,
                   STATUS_ACCESS_VIOLATION,
                   STATUS_DATATYPE_MISALIGNMENT,
                   STATUS_BREAKPOINT,
                   STATUS_SINGLE_STEP,
                   STATUS_ARRAY_BOUNDS_EXCEEDED,
                   STATUS_FLOAT_DENORMAL_OPERAND,
                   STATUS_FLOAT_DIVIDE_BY_ZERO,
                   STATUS_FLOAT_INEXACT_RESULT,
                   STATUS_FLOAT_INVALID_OPERATION,
                   STATUS_FLOAT_OVERFLOW,
                   STATUS_FLOAT_STACK_CHECK,
                   STATUS_FLOAT_UNDERFLOW,
                   STATUS_INTEGER_DIVIDE_BY_ZERO,
                   STATUS_INTEGER_OVERFLOW,
                   STATUS_PRIVILEGED_INSTRUCTION,
                   STATUS_IN_PAGE_ERROR,
                   STATUS_ILLEGAL_INSTRUCTION,
                   STATUS_NONCONTINUABLE_EXCEPTION,
                   STATUS_STACK_OVERFLOW,
                   STATUS_INVALID_DISPOSITION,
                   STATUS_GUARD_PAGE_VIOLATION,
                   STATUS_INVALID_HANDLE,
                   STATUS_CONTROL_C_EXIT,

                   ACCESS_MASK,

                   LDT_ENTRY,
                   CONTEXT,
                   PCONTEXT,

                   PROCESSOR_ARCHITECTURE_ENUM,

                   THREAD_BASE_PRIORITY_MIN,
                   THREAD_BASE_PRIORITY_MAX,
                   THREAD_BASE_PRIORITY_LOWRT,
                   THREAD_BASE_PRIORITY_IDLE,

                   EXCEPTION_RECORD,
                   EXCEPTION_POINTERS,

                   MUTANT_QUERY_STATE,
                   MUTANT_ALL_ACCESS,
                   FILE_BIT_ENUM,
                   FILE_BIT_SET,
                   FILE_SHARE_MODE,
                   FILE_ATTRIBUTE_SET,
                   FILE_NOTIFY_SET,

                   FILE_CASE_PRESERVED_NAMES,
                   FILE_CASE_SENSITIVE_SEARCH,
                   FILE_UNICODE_ON_DISK,
                   FILE_PERSISTENT_ACLS,
                   FILE_VOLUME_IS_COMPRESSED,
                   FILE_FILE_COMPRESSION,

                   FILESYSTEM_FLAGS,

                   SECTION_QUERY,
                   SECTION_MAP_WRITE,
                   SECTION_MAP_READ,
                   SECTION_ALL_ACCESS,
                   GENERIC_MAPPING,
                   PGENERIC_MAPPING,

                   DUPLICATE_TYPE,
                   TOKEN_TYPE,
                   PSID, PSECURITY_DESCRIPTOR,
                   SID_IDENTIFIER_AUTHORITY,
                   PSID_IDENTIFIER_AUTHORITY,
                   SID_NAME_USE,
                   ACL, PACL, ACL_INFORMATION_CLASS,
                   MEMORY_BASIC_INFORMATION,
                   LUID, PRIVILEGE_SET, PPRIVILEGE_SET,
                   SECURITY_IMPERSONATION_LEVEL,
                   SECURITY_INFORMATION,
                   SECURITY_DESCRIPTOR_CONTROL,

                   TOKEN_INFORMATION_CLASS,
                   TOKEN_PRIVILEGES,
                   TOKEN_GROUPS,

                   IS_TEXT_UNICODE_SET,
                   RTL_CRITICAL_SECTION,       PRTL_CRITICAL_SECTION,
                   RTL_CRITICAL_SECTION_DEBUG, PRTL_CRITICAL_SECTION_DEBUG,

                   RtlMoveMemory,
                   RtlCopyMemory,
                   RtlFillMemory,
                   RtlZeroMemory,

                   EVENTLOG_TYPE, EVENTLOG_READ_SET,

                   TAPE_GET_POSITION_TYPE,
                   TAPE_SET_POSITION_TYPE,
                   TAPE_OPERATION,
                   TAPE_ERASE_TYPE,
                   TAPE_PARTITION_TYPE,
                   TAPE_MARK_TYPE,

                   PROTECT_SET,

                   HEAP_SET,

                   BYTEARRAY8,
                   GUID,
                   PGUID;

(* -------------------------------------------------------- *)

CONST INVALID_HANDLE_VALUE = SYSTEM.CAST (HANDLE, VAL (INTEGER, -1));
      INVALID_FILE_SIZE    = VAL (DWORD, 0FFFFFFFFh);

TYPE MOVE_TYPE = (FILE_BEGIN,   (* 0 *)
                  FILE_CURRENT, (* 1 *)
                  FILE_END);    (* 2 *)

CONST TIME_ZONE_ID_INVALID = VAL (DWORD, 0FFFFFFFFh);

CONST WAIT_FAILED      = VAL (DWORD, 0FFFFFFFFh);
      WAIT_OBJECT_0    = STATUS_WAIT_0 + 0;
      WAIT_ABANDONED   = STATUS_ABANDONED_WAIT_0 + 0;
      WAIT_ABANDONED_0 = STATUS_ABANDONED_WAIT_0 + 0;

      WAIT_TIMEOUT                       = STATUS_TIMEOUT;
      WAIT_IO_COMPLETION                 = STATUS_USER_APC;
      STILL_ACTIVE                       = STATUS_PENDING;
      EXCEPTION_ACCESS_VIOLATION         = STATUS_ACCESS_VIOLATION;
      EXCEPTION_DATATYPE_MISALIGNMENT    = STATUS_DATATYPE_MISALIGNMENT;
      EXCEPTION_BREAKPOINT               = STATUS_BREAKPOINT;
      EXCEPTION_SINGLE_STEP              = STATUS_SINGLE_STEP;
      EXCEPTION_ARRAY_BOUNDS_EXCEEDED    = STATUS_ARRAY_BOUNDS_EXCEEDED;
      EXCEPTION_FLT_DENORMAL_OPERAND     = STATUS_FLOAT_DENORMAL_OPERAND;
      EXCEPTION_FLT_DIVIDE_BY_ZERO       = STATUS_FLOAT_DIVIDE_BY_ZERO;
      EXCEPTION_FLT_INEXACT_RESULT       = STATUS_FLOAT_INEXACT_RESULT;
      EXCEPTION_FLT_INVALID_OPERATION    = STATUS_FLOAT_INVALID_OPERATION;
      EXCEPTION_FLT_OVERFLOW             = STATUS_FLOAT_OVERFLOW;
      EXCEPTION_FLT_STACK_CHECK          = STATUS_FLOAT_STACK_CHECK;
      EXCEPTION_FLT_UNDERFLOW            = STATUS_FLOAT_UNDERFLOW;
      EXCEPTION_INT_DIVIDE_BY_ZERO       = STATUS_INTEGER_DIVIDE_BY_ZERO;
      EXCEPTION_INT_OVERFLOW             = STATUS_INTEGER_OVERFLOW;
      EXCEPTION_PRIV_INSTRUCTION         = STATUS_PRIVILEGED_INSTRUCTION;
      EXCEPTION_IN_PAGE_ERROR            = STATUS_IN_PAGE_ERROR;
      EXCEPTION_ILLEGAL_INSTRUCTION      = STATUS_ILLEGAL_INSTRUCTION;
      EXCEPTION_NONCONTINUABLE_EXCEPTION = STATUS_NONCONTINUABLE_EXCEPTION;
      EXCEPTION_STACK_OVERFLOW           = STATUS_STACK_OVERFLOW;
      EXCEPTION_INVALID_DISPOSITION      = STATUS_INVALID_DISPOSITION;
      EXCEPTION_GUARD_PAGE               = STATUS_GUARD_PAGE_VIOLATION;
      EXCEPTION_INVALID_HANDLE           = STATUS_INVALID_HANDLE;
      CONTROL_C_EXIT                     = STATUS_CONTROL_C_EXIT;

CONST MoveMemory = RtlMoveMemory;
      CopyMemory = RtlCopyMemory;
      FillMemory = RtlFillMemory;
      ZeroMemory = RtlZeroMemory;

(* File creation flags must start at the high end since they
   are combined with the attributes
*)

TYPE FILE_FLAG_ENUM = FILE_BIT_ENUM;

CONST FILE_FLAG__WRITE_THROUGH     = F_31;
      FILE_FLAG__OVERLAPPED        = F_30;
      FILE_FLAG__NO_BUFFERING      = F_29;
      FILE_FLAG__RANDOM_ACCESS     = F_28;
      FILE_FLAG__SEQUENTIAL_SCAN   = F_27;
      FILE_FLAG__DELETE_ON_CLOSE   = F_26;
      FILE_FLAG__BACKUP_SEMANTICS  = F_25;
      FILE_FLAG__POSIX_SEMANTICS   = F_24;

TYPE FILE_FLAG_SET = FILE_BIT_SET;

CONST FILE_FLAG_WRITE_THROUGH     = FILE_FLAG_SET {FILE_FLAG__WRITE_THROUGH   }; (* 80000000h *)
      FILE_FLAG_OVERLAPPED        = FILE_FLAG_SET {FILE_FLAG__OVERLAPPED      }; (* 40000000h *)
      FILE_FLAG_NO_BUFFERING      = FILE_FLAG_SET {FILE_FLAG__NO_BUFFERING    }; (* 20000000h *)
      FILE_FLAG_RANDOM_ACCESS     = FILE_FLAG_SET {FILE_FLAG__RANDOM_ACCESS   }; (* 10000000h *)
      FILE_FLAG_SEQUENTIAL_SCAN   = FILE_FLAG_SET {FILE_FLAG__SEQUENTIAL_SCAN }; (* 08000000h *)
      FILE_FLAG_DELETE_ON_CLOSE   = FILE_FLAG_SET {FILE_FLAG__DELETE_ON_CLOSE }; (* 04000000h *)
      FILE_FLAG_BACKUP_SEMANTICS  = FILE_FLAG_SET {FILE_FLAG__BACKUP_SEMANTICS}; (* 02000000h *)
      FILE_FLAG_POSIX_SEMANTICS   = FILE_FLAG_SET {FILE_FLAG__POSIX_SEMANTICS }; (* 01000000h *)

TYPE CREATION_DISTRIBUTION = (CREATE_0,
                              CREATE_NEW,         (* 1 *)
                              CREATE_ALWAYS,      (* 2 *)
                              OPEN_EXISTING,      (* 3 *)
                              OPEN_ALWAYS,        (* 4 *)
                              TRUNCATE_EXISTING); (* 5 *)

(*
** Define possible return codes from the CopyFileEx callback routine
*)

TYPE PROGRESS_ENUM = (PROGRESS_CONTINUE, (* 0 *)
                      PROGRESS_CANCEL,   (* 1 *)
                      PROGRESS_STOP,     (* 2 *)
                      PROGRESS_QUIET);   (* 3 *)

(*
** Define CopyFileEx callback routine state change values
*)

TYPE COPYFILEEX_CALLBACK_ENUM = (CALLBACK_CHUNK_FINISHED, (* 0x00000000 *)
                                 CALLBACK_STREAM_SWITCH); (* 0x00000001 *)

(*
** Define CopyFileEx option flags
*)

TYPE COPY_FILE_ENUM = (COPY_FILE__FAIL_IF_EXISTS, (* 0 *)
                       COPY_FILE__RESTARTABLE);   (* 1 *)

     COPY_FILE_SET = SET OF COPY_FILE_ENUM;

CONST COPY_FILE_FAIL_IF_EXISTS = COPY_FILE_SET {COPY_FILE__FAIL_IF_EXISTS};  (* 0x00000001 *)
      COPY_FILE_RESTARTABLE    = COPY_FILE_SET {COPY_FILE__RESTARTABLE};     (* 0x00000002 *)

(* Define the NamedPipe definitions *)

(* Define the dwOpenMode values for CreateNamedPipe *)

TYPE PIPE_ACCESS_SET = FILE_BIT_SET;

CONST PIPE_ACCESS_INBOUND  = SYSTEM.CAST (PIPE_ACCESS_SET, 00000001h);
      PIPE_ACCESS_OUTBOUND = SYSTEM.CAST (PIPE_ACCESS_SET, 00000002h);
      PIPE_ACCESS_DUPLEX   = SYSTEM.CAST (PIPE_ACCESS_SET, 00000003h);

(* Define the dwPipeMode values for CreateNamedPipe *)

TYPE PIPE_MODE_ENUM = (PIPE__NOWAIT,            (* 0 *)
                       PIPE__READMODE_MESSAGE,  (* 1 *)
                       PIPE__TYPE_MESSAGE);     (* 2 *)

TYPE PIPE_MODE_SET = SET OF PIPE_MODE_ENUM;

CONST PIPE_WAIT                  = PIPE_MODE_SET {};                      (* 0x00000000 *)
      PIPE_NOWAIT                = PIPE_MODE_SET {PIPE__NOWAIT};          (* 0x00000001 *)
      PIPE_READMODE_BYTE         = PIPE_MODE_SET {};                      (* 0x00000000 *)
      PIPE_READMODE_MESSAGE      = PIPE_MODE_SET {PIPE__READMODE_MESSAGE};(* 0x00000002 *)
      PIPE_TYPE_BYTE             = PIPE_MODE_SET {};                      (* 0x00000000 *)
      PIPE_TYPE_MESSAGE          = PIPE_MODE_SET {PIPE__TYPE_MESSAGE};    (* 0x00000004 *)

(* Define the Named Pipe End flags for GetNamedPipeInfo *)

CONST PIPE__SERVER_END = PIPE__NOWAIT; (* 0 *)

      PIPE_CLIENT_END  = PIPE_MODE_SET {};                 (* 0x00000000 *)
      PIPE_SERVER_END  = PIPE_MODE_SET {PIPE__SERVER_END}; (* 0x00000001 *)

(* Define the well known values for CreateNamedPipe nMaxInstances *)

CONST  PIPE_UNLIMITED_INSTANCES  = 255;


(* Define the Security Quality of Service bits to be passed
   into CreateFile
*)

TYPE SECURITY_ENUM = FILE_BIT_ENUM;

CONST SECURITY__CONTEXT_TRACKING = F_18;
      SECURITY__EFFECTIVE_ONLY   = F_19;
      SECURITY__SQOS_PRESENT     = F_20;

TYPE SECURITY_SET = FILE_BIT_SET;

CONST SECURITY_ANONYMOUS        = SYSTEM.CAST (SECURITY_SET, 65536 * ORD (SecurityAnonymous));
      SECURITY_IDENTIFICATION   = SYSTEM.CAST (SECURITY_SET, 65536 * ORD (SecurityIdentification));
      SECURITY_IMPERSONATION    = SYSTEM.CAST (SECURITY_SET, 65536 * ORD (SecurityImpersonation));
      SECURITY_DELEGATION       = SYSTEM.CAST (SECURITY_SET, 65536 * ORD (SecurityDelegation));

      SECURITY_CONTEXT_TRACKING = SECURITY_SET {SECURITY__CONTEXT_TRACKING}; (* 00040000h *)
      SECURITY_EFFECTIVE_ONLY   = SECURITY_SET {SECURITY__EFFECTIVE_ONLY};   (* 00080000h *)

      SECURITY_SQOS_PRESENT     = SECURITY_SET {SECURITY__SQOS_PRESENT};     (* 00100000h *)

      SECURITY_VALID_SQOS_FLAGS = SECURITY_SET {F_16..F_20};                (* 001F0000h *)

(*  File structures *)

TYPE OVERLAPPED = RECORD
                       Internal     : DWORD;
                       InternalHigh : DWORD;
                       Offset       : DWORD;
                       OffsetHigh   : DWORD;
                       hEvent       : HANDLE;
                  END;
    POVERLAPPED = POINTER TO OVERLAPPED;

TYPE SECURITY_ATTRIBUTES = RECORD
                                nLength              : DWORD;
                                lpSecurityDescriptor : PVOID;
                                bInheritHandle       : BOOL;
                           END;
     PSECURITY_ATTRIBUTES = POINTER TO SECURITY_ATTRIBUTES;

TYPE PROCESS_INFORMATION = RECORD
                                hProcess    : HANDLE;
                                hThread     : HANDLE;
                                dwProcessId : DWORD;
                                dwThreadId  : DWORD;
                           END;
     PPROCESS_INFORMATION = POINTER TO PROCESS_INFORMATION;

(* File System time stamps are represented with the following structure: *)

TYPE FILETIME = RECORD
                     dwLowDateTime  : DWORD;
                     dwHighDateTime : DWORD;
                END;
     PFILETIME  = POINTER TO FILETIME;

(* System time is represented with the following structure: *)

TYPE SYSTEMTIME = RECORD
                       wYear         : WORD;
                       wMonth        : WORD;
                       wDayOfWeek    : WORD;
                       wDay          : WORD;
                       wHour         : WORD;
                       wMinute       : WORD;
                       wSecond       : WORD;
                       wMilliseconds : WORD;
                  END;
     PSYSTEMTIME = POINTER TO SYSTEMTIME;

TYPE PTHREAD_START_ROUTINE = PROCEDURE ((* ThreadParameter : *) PVOID) : DWORD;
TYPE PFIBER_START_ROUTINE  = PROCEDURE ((* FiberParameter  : *) PVOID);

TYPE  CRITICAL_SECTION =  RTL_CRITICAL_SECTION;
TYPE PCRITICAL_SECTION = PRTL_CRITICAL_SECTION;

TYPE  CRITICAL_SECTION_DEBUG =  RTL_CRITICAL_SECTION_DEBUG;
TYPE PCRITICAL_SECTION_DEBUG = PRTL_CRITICAL_SECTION_DEBUG;

CONST MUTEX_MODIFY_STATE = MUTANT_QUERY_STATE;
CONST MUTEX_ALL_ACCESS   = MUTANT_ALL_ACCESS;

(* Serial provider type. *)

CONST SP_SERIALCOMM = DWORD (00000001h);

(* Provider SubTypes *)

TYPE PST_TYPE = DWORD;

CONST  PST_UNSPECIFIED      = VAL (PST_TYPE, 00000000h);
       PST_RS232            = VAL (PST_TYPE, 00000001h);
       PST_PARALLELPORT     = VAL (PST_TYPE, 00000002h);
       PST_RS422            = VAL (PST_TYPE, 00000003h);
       PST_RS423            = VAL (PST_TYPE, 00000004h);
       PST_RS449            = VAL (PST_TYPE, 00000005h);
       PST_MODEM            = VAL (PST_TYPE, 00000006h);
       PST_FAX              = VAL (PST_TYPE, 00000021h);
       PST_SCANNER          = VAL (PST_TYPE, 00000022h);
       PST_NETWORK_BRIDGE   = VAL (PST_TYPE, 00000100h);
       PST_LAT              = VAL (PST_TYPE, 00000101h);
       PST_TCPIP_TELNET     = VAL (PST_TYPE, 00000102h);
       PST_X25              = VAL (PST_TYPE, 00000103h);

(* Provider capabilities flags. *)

TYPE PCF_ENUM = (PCF__DTRDSR,        (* 0 *)
                 PCF__RTSCTS,        (* 1 *)
                 PCF__RLSD,          (* 2 *)
                 PCF__PARITY_CHECK,  (* 3 *)
                 PCF__XONXOFF,       (* 4 *)
                 PCF__SETXCHAR,      (* 5 *)
                 PCF__TOTALTIMEOUTS, (* 6 *)
                 PCF__INTTIMEOUTS,   (* 7 *)
                 PCF__SPECIALCHARS,  (* 8 *)
                 PCF__16BITMODE);    (* 9 *)

     PCF_SET = SET OF PCF_ENUM;

CONST PCF_DTRDSR         = PCF_SET {PCF__DTRDSR};        (* 0001h *)
      PCF_RTSCTS         = PCF_SET {PCF__RTSCTS};        (* 0002h *)
      PCF_RLSD           = PCF_SET {PCF__RLSD};          (* 0004h *)
      PCF_PARITY_CHECK   = PCF_SET {PCF__PARITY_CHECK};  (* 0008h *)
      PCF_XONXOFF        = PCF_SET {PCF__XONXOFF};       (* 0010h *)
      PCF_SETXCHAR       = PCF_SET {PCF__SETXCHAR};      (* 0020h *)
      PCF_TOTALTIMEOUTS  = PCF_SET {PCF__TOTALTIMEOUTS}; (* 0040h *)
      PCF_INTTIMEOUTS    = PCF_SET {PCF__INTTIMEOUTS};   (* 0080h *)
      PCF_SPECIALCHARS   = PCF_SET {PCF__SPECIALCHARS};  (* 0100h *)
      PCF_16BITMODE      = PCF_SET {PCF__16BITMODE};     (* 0200h *)

(* Comm provider settable parameters. *)

TYPE SP_ENUM = (SP__PARITY,       (* 0 *)
                SP__BAUD,         (* 1 *)
                SP__DATABITS,     (* 2 *)
                SP__STOPBITS,     (* 3 *)
                SP__HANDSHAKING,  (* 4 *)
                SP__PARITY_CHECK, (* 5 *)
                SP__RLSD);        (* 6 *)

     SP_SET = SET OF SP_ENUM;

CONST  SP_PARITY         = SP_SET {SP__PARITY};       (* 0001h*)
       SP_BAUD           = SP_SET {SP__BAUD};         (* 0002h*)
       SP_DATABITS       = SP_SET {SP__DATABITS};     (* 0004h*)
       SP_STOPBITS       = SP_SET {SP__STOPBITS};     (* 0008h*)
       SP_HANDSHAKING    = SP_SET {SP__HANDSHAKING};  (* 0010h*)
       SP_PARITY_CHECK   = SP_SET {SP__PARITY_CHECK}; (* 0020h*)
       SP_RLSD           = SP_SET {SP__RLSD};         (* 0040h*)

(* Settable baud rates in the provider. *)

TYPE BAUD_ENUM = (BAUD__075,          (*  0 *)
                  BAUD__110,          (*  1 *)
                  BAUD__134_5,        (*  2 *)
                  BAUD__150,          (*  3 *)
                  BAUD__300,          (*  4 *)
                  BAUD__600,          (*  5 *)
                  BAUD__1200,         (*  6 *)
                  BAUD__1800,         (*  7 *)
                  BAUD__2400,         (*  8 *)
                  BAUD__4800,         (*  9 *)
                  BAUD__7200,         (* 10 *)
                  BAUD__9600,         (* 11 *)
                  BAUD__14400,        (* 12 *)
                  BAUD__19200,        (* 13 *)
                  BAUD__38400,        (* 14 *)
                  BAUD__56K,          (* 15 *)
                  BAUD__128K,         (* 16 *)
                  BAUD__115200,       (* 17 *)
                  BAUD__57600,        (* 18 *)
                  BAUD__19, BAUD__20,
                  BAUD__21, BAUD__22,
                  BAUD__23, BAUD__24,
                  BAUD__25, BAUD__26,
                  BAUD__27,
                  BAUD__USER);        (* 28 *)

TYPE BAUD_SET = SET OF BAUD_ENUM;

CONST  BAUD_075          = BAUD_SET {BAUD__075};    (* 0x00000001 *)
       BAUD_110          = BAUD_SET {BAUD__110};    (* 0x00000002 *)
       BAUD_134_5        = BAUD_SET {BAUD__134_5};  (* 0x00000004 *)
       BAUD_150          = BAUD_SET {BAUD__150};    (* 0x00000008 *)
       BAUD_300          = BAUD_SET {BAUD__300};    (* 0x00000010 *)
       BAUD_600          = BAUD_SET {BAUD__600};    (* 0x00000020 *)
       BAUD_1200         = BAUD_SET {BAUD__1200};   (* 0x00000040 *)
       BAUD_1800         = BAUD_SET {BAUD__1800};   (* 0x00000080 *)
       BAUD_2400         = BAUD_SET {BAUD__2400};   (* 0x00000100 *)
       BAUD_4800         = BAUD_SET {BAUD__4800};   (* 0x00000200 *)
       BAUD_7200         = BAUD_SET {BAUD__7200};   (* 0x00000400 *)
       BAUD_9600         = BAUD_SET {BAUD__9600};   (* 0x00000800 *)
       BAUD_14400        = BAUD_SET {BAUD__14400};  (* 0x00001000 *)
       BAUD_19200        = BAUD_SET {BAUD__19200};  (* 0x00002000 *)
       BAUD_38400        = BAUD_SET {BAUD__38400};  (* 0x00004000 *)
       BAUD_56K          = BAUD_SET {BAUD__56K};    (* 0x00008000 *)
       BAUD_128K         = BAUD_SET {BAUD__128K};   (* 0x00010000 *)
       BAUD_115200       = BAUD_SET {BAUD__115200}; (* 0x00020000 *)
       BAUD_57600        = BAUD_SET {BAUD__57600};  (* 0x00040000 *)
       BAUD_USER         = BAUD_SET {BAUD__USER};   (* 0x10000000 *)

(* Settable Data Bits *)

TYPE DATABITS_ENUM = (DATABITS__5,    (* 0 *)
                      DATABITS__6,    (* 1 *)
                      DATABITS__7,    (* 2 *)
                      DATABITS__8,    (* 3 *)
                      DATABITS__16,   (* 4 *)
                      DATABITS__16X); (* 5 *)

<* PUSH *> <* SETSIZE = "2" *>

TYPE DATABITS_SET = SET OF DATABITS_ENUM;

CONST  DATABITS_5   = DATABITS_SET {DATABITS__5};   (* 0x0001 *)
       DATABITS_6   = DATABITS_SET {DATABITS__6};   (* 0x0002 *)
       DATABITS_7   = DATABITS_SET {DATABITS__7};   (* 0x0004 *)
       DATABITS_8   = DATABITS_SET {DATABITS__8};   (* 0x0008 *)
       DATABITS_16  = DATABITS_SET {DATABITS__16};  (* 0x0010 *)
       DATABITS_16X = DATABITS_SET {DATABITS__16X}; (* 0x0020 *)

<* POP *>

(* Settable Stop and Parity bits. *)

TYPE STOPBITS_ENUM = (STOPBITS__10,    (*  0 *)
                      STOPBITS__15,    (*  1 *)
                      STOPBITS__20,    (*  2 *)
                      STOPBITS__3,
                      STOPBITS__4,
                      STOPBITS__5,
                      STOPBITS__6,
                      STOPBITS__7,
                      PARITY__NONE,    (*  8 *)
                      PARITY__ODD,     (*  9 *)
                      PARITY__EVEN,    (* 10 *)
                      PARITY__MARK,    (* 11 *)
                      PARITY__SPACE);  (* 12 *)

<* PUSH *> <* SETSIZE = "2" *>

TYPE STOPBITS_SET = SET OF STOPBITS_ENUM;

CONST  STOPBITS_10  = STOPBITS_SET {STOPBITS__10};  (* 0x0001 *)
       STOPBITS_15  = STOPBITS_SET {STOPBITS__15};  (* 0x0002 *)
       STOPBITS_20  = STOPBITS_SET {STOPBITS__20};  (* 0x0004 *)
       PARITY_NONE  = STOPBITS_SET {PARITY__NONE};  (* 0x0100 *)
       PARITY_ODD   = STOPBITS_SET {PARITY__ODD};   (* 0x0200 *)
       PARITY_EVEN  = STOPBITS_SET {PARITY__EVEN};  (* 0x0400 *)
       PARITY_MARK  = STOPBITS_SET {PARITY__MARK};  (* 0x0800 *)
       PARITY_SPACE = STOPBITS_SET {PARITY__SPACE}; (* 0x1000 *)

<* POP *>

TYPE COMMPROP = RECORD
                     wPacketLength       :  WORD;
                     wPacketVersion      :  WORD;
                     dwServiceMask       : DWORD;
                     dwReserved1         : DWORD;
                     dwMaxTxQueue        : DWORD;
                     dwMaxRxQueue        : DWORD;
                     dwMaxBaud           : BAUD_SET;
                     dwProvSubType       : PST_TYPE;
                     dwProvCapabilities  : PCF_SET;
                     dwSettableParams    : SP_SET;
                     dwSettableBaud      : BAUD_SET;
                     wSettableData       : DATABITS_SET;
                     wSettableStopParity : STOPBITS_SET;
                     dwCurrentTxQueue    : DWORD;
                     dwCurrentRxQueue    : DWORD;
                     dwProvSpec1         : DWORD;
                     dwProvSpec2         : DWORD;
                     wcProvChar          : ARRAY [0..0] OF WCHAR;
                 END;
     PCOMMPROP = POINTER TO COMMPROP;

(* Set dwProvSpec1 to COMMPROP_INITIALIZED to indicate that wPacketLength
   is valid before a call to GetCommProperties().
*)

CONST COMMPROP_INITIALIZED = SYSTEM.CAST (DWORD, VAL (ULONG, 0E73CF52Eh));

(* Originally COMSTAT was a structure containing bit fields fCtsHold, ..., fTxim;
   they were collected in a set
*)

TYPE COMSTAT_FLAGS = (COMSTAT_fCtsHold,
                      COMSTAT_fDsrHold,
                      COMSTAT_fRlsdHold,
                      COMSTAT_fXoffHold,
                      COMSTAT_fXoffSent,
                      COMSTAT_fEof,
                      COMSTAT_fTxim);

     COMSTAT_SET = SET OF COMSTAT_FLAGS;

TYPE COMSTAT = RECORD
                      Flags    : COMSTAT_SET;
                      cbInQue  : DWORD;
                      cbOutQue : DWORD;
               END;
    PCOMSTAT = POINTER TO COMSTAT;

(* Originally DCB was a structure containing bit fields fBinary, ..., fAbortOnError;
   they were collected in a set.
   Fields fDtrControl and fRtsControl were 2 bits wide; so two set elements were
   assigned to them
*)

TYPE DCB_FLAG  = (DCB_fBinary,           (* Binary Mode (skip EOF check)    *)
                  DCB_fParity,           (* Enable parity checking          *)
                  DCB_fOutxCtsFlow,      (* CTS handshaking on output       *)
                  DCB_fOutxDsrFlow,      (* DSR handshaking on output       *)
                  DCB_fDtrControl_1,     (* DTR Flow control                *)
                  DCB_fDtrControl_2,
                  DCB_fDsrSensitivity,   (* DSR Sensitivity                 *)
                  DCB_fTXContinueOnXoff, (* Continue TX when Xoff sent      *)
                  DCB_fOutX,             (* Enable output X-ON/X-OFF        *)
                  DCB_fInX,              (* Enable input X-ON/X-OFF         *)
                  DCB_fErrorChar,        (* Enable Err Replacement          *)
                  DCB_fNull,             (* Enable Null stripping           *)
                  DCB_fRtsControl_1,     (* Rts Flow control                *)
                  DCB_fRtsControl_2,
                  DCB_fAbortOnError);    (* Abort all reads and writes on Error *)

     DCB_FLAGS = SET OF DCB_FLAG;

(* DTR Control Flow Values. *)

CONST DTR_CONTROL_DISABLE   = DCB_FLAGS {};                  (* 0 *)
      DTR_CONTROL_ENABLE    = DCB_FLAGS {DCB_fDtrControl_1}; (* 1 *)
      DTR_CONTROL_HANDSHAKE = DCB_FLAGS {DCB_fDtrControl_2}; (* 2 *)

(* RTS Control Flow Values *)

CONST RTS_CONTROL_DISABLE   = DCB_FLAGS {};                  (* 0 *)
      RTS_CONTROL_ENABLE    = DCB_FLAGS {DCB_fRtsControl_1}; (* 1 *)
      RTS_CONTROL_HANDSHAKE = DCB_FLAGS {DCB_fRtsControl_2}; (* 2 *)
      RTS_CONTROL_TOGGLE    = DCB_FLAGS {DCB_fRtsControl_1, DCB_fRtsControl_2}; (* 3 *)

(* Parity values for DCB *)

<* PUSH *> <* ENUMSIZE = "1" *>

TYPE PARITY_TYPE = (NOPARITY,      (* 0 *)
                    ODDPARITY,     (* 1 *)
                    EVENPARITY,    (* 2 *)
                    MARKPARITY,    (* 3 *)
                    SPACEPARITY);  (* 4 *)

<* POP *>

(* Stop bits values for DCB *)

<* PUSH *> <* ENUMSIZE = "1" *>

TYPE STOPBITS_TYPE = (ONESTOPBIT,     (* 0 *)
                      ONE5STOPBITS,   (* 1 *)
                      TWOSTOPBITS);   (* 2 *)

<* POP *>

TYPE DCB = RECORD
                  DCBlength  : DWORD;         (* sizeof(DCB)                     *)
                  BaudRate   : DWORD;         (* Baudrate at which running       *)
                  Flags      : DCB_FLAGS;
                  wReserved  : WORD;          (* Not currently used              *)
                  XonLim     : WORD;          (* Transmit X-ON threshold         *)
                  XoffLim    : WORD;          (* Transmit X-OFF threshold        *)
                  ByteSize   : BYTE;          (* Number of bits/byte, 4-8        *)
                  Parity     : PARITY_TYPE;   (* 0-4=None,Odd,Even,Mark,Space    *)
                  StopBits   : STOPBITS_TYPE; (* 0,1,2 = 1, 1.5, 2               *)
                  XonChar    : CHAR;          (* Tx and Rx X-ON character        *)
                  XoffChar   : CHAR;          (* Tx and Rx X-OFF character       *)
                  ErrorChar  : CHAR;          (* Error replacement char          *)
                  EofChar    : CHAR;          (* End of Input character          *)
                  EvtChar    : CHAR;          (* Received Event character        *)
                  wReserved1 : WORD;          (* Fill for now.                   *)
           END;
    PDCB = POINTER TO DCB;

TYPE COMMTIMEOUTS =
     RECORD
          ReadIntervalTimeout         : DWORD; (* Maximum time between read chars. *)
          ReadTotalTimeoutMultiplier  : DWORD; (* Multiplier of characters.        *)
          ReadTotalTimeoutConstant    : DWORD; (* Constant in milliseconds.        *)
          WriteTotalTimeoutMultiplier : DWORD; (* Multiplier of characters.        *)
          WriteTotalTimeoutConstant   : DWORD; (* Constant in milliseconds.        *)
     END;
     PCOMMTIMEOUTS = POINTER TO COMMTIMEOUTS;

TYPE COMMCONFIG =
     RECORD
         dwSize            : DWORD;    (* Size of the entire struct *)
         wVersion          : WORD;     (* version of the structure *)
         wReserved         : WORD;     (* alignment *)
         dcb               : DCB;      (* device control block *)
         dwProviderSubType : PST_TYPE; (* ordinal value for identifying
                                          provider-defined data structure format*)
         dwProviderOffset  : DWORD;    (* Specifies the offset of provider specific
                                          data field in bytes from the start *)
         dwProviderSize    : DWORD;    (* size of the provider-specific data field *)
         wcProviderData    : ARRAY [0..1] OF WCHAR; (* provider-specific data *)
     END;
     PCOMMCONFIG = POINTER TO COMMCONFIG;

TYPE SYSTEM_INFO =
     RECORD
         CASE : BOOLEAN OF
         | FALSE: dwOemId : DWORD;          (* Obsolete field...do not use *)
         | TRUE:  wProcessorArchitecture : PROCESSOR_ARCHITECTURE_ENUM;
                  wReserved : WORD;
         END;
         dwPageSize                  : DWORD;
         lpMinimumApplicationAddress : PVOID;
         lpMaximumApplicationAddress : PVOID;
         dwActiveProcessorMask       : BITSET;
         dwNumberOfProcessors        : DWORD;
         dwProcessorType             : DWORD;
         dwAllocationGranularity     : DWORD;
         wProcessorLevel             : WORD;
         wProcessorRevision          : WORD;
     END;
     PSYSTEM_INFO = POINTER TO SYSTEM_INFO;

(* Global Memory Flags *)

TYPE GMEM_ENUM = (GMEM__0,
                  GMEM__MOVEABLE,       (*  1 *)
                  GMEM__2,
                  GMEM__3,
                  GMEM__NOCOMPACT,      (*  4 *)
                  GMEM__NODISCARD,      (*  5 *)
                  GMEM__ZEROINIT,       (*  6 *)
                  GMEM__MODIFY,         (*  7 *)
                  GMEM__DISCARDABLE,    (*  8 *)
                  GMEM__9,
                  GMEM__10,
                  GMEM__11,
                  GMEM__NOT_BANKED,     (* 12 *)
                  GMEM__SHARE,          (* 13 *)
                  GMEM__NOTIFY,         (* 14 *)
                  GMEM__INVALID_HANDLE);(* 15 *)

TYPE GMEM_SET = SET OF GMEM_ENUM;

CONST GMEM_FIXED          = GMEM_SET {};                     (* 0x0000 *)
      GMEM_MOVEABLE       = GMEM_SET {GMEM__MOVEABLE};       (* 0x0002 *)
      GMEM_NOCOMPACT      = GMEM_SET {GMEM__NOCOMPACT};      (* 0x0010 *)
      GMEM_NODISCARD      = GMEM_SET {GMEM__NODISCARD};      (* 0x0020 *)
      GMEM_ZEROINIT       = GMEM_SET {GMEM__ZEROINIT};       (* 0x0040 *)
      GMEM_MODIFY         = GMEM_SET {GMEM__MODIFY};         (* 0x0080 *)
      GMEM_DISCARDABLE    = GMEM_SET {GMEM__DISCARDABLE};    (* 0x0100 *)
      GMEM_NOT_BANKED     = GMEM_SET {GMEM__NOT_BANKED};     (* 0x1000 *)
      GMEM_SHARE          = GMEM_SET {GMEM__SHARE};          (* 0x2000 *)
      GMEM_NOTIFY         = GMEM_SET {GMEM__NOTIFY};         (* 0x4000 *)
      GMEM_INVALID_HANDLE = GMEM_SET {GMEM__INVALID_HANDLE}; (* 0x8000 *)

      GMEM_VALID_FLAGS    = GMEM_SET {GMEM__NOTIFY..GMEM__DISCARDABLE,
                                      GMEM__ZEROINIT..GMEM__NOCOMPACT,
                                      GMEM__MOVEABLE};                 (* 0x7F72 *)

      GMEM_LOWER          = GMEM_NOT_BANKED;
      GMEM_DDESHARE       = GMEM_SHARE;

      GHND = GMEM_MOVEABLE + GMEM_ZEROINIT;
      GPTR = GMEM_FIXED + GMEM_ZEROINIT;

PROCEDURE GlobalDiscard (h : HGLOBAL) : HGLOBAL;  (* was a macro; now in RTL *)

(* Flags returned by GlobalFlags (in addition to GMEM_DISCARDABLE) *)

CONST GMEM__DISCARDED = GMEM__NOTIFY;

      GMEM_DISCARDED = GMEM_SET {GMEM__DISCARDED}; (* 0x4000 *)

      GMEM_LOCKCOUNT = SYSTEM.CAST (GMEM_SET, VAL (DWORD, 00FFh));

TYPE MEMORYSTATUS = RECORD
                         dwLength        : DWORD;
                         dwMemoryLoad    : DWORD;
                         dwTotalPhys     : DWORD;
                         dwAvailPhys     : DWORD;
                         dwTotalPageFile : DWORD;
                         dwAvailPageFile : DWORD;
                         dwTotalVirtual  : DWORD;
                         dwAvailVirtual  : DWORD;
                    END;
     PMEMORYSTATUS = POINTER TO MEMORYSTATUS;

(* Local Memory Flags *)

TYPE LMEM_ENUM = (LMEM__0,
                  LMEM__MOVEABLE,       (*  1 *)
                  LMEM__2,
                  LMEM__3,
                  LMEM__NOCOMPACT,      (*  4 *)
                  LMEM__NODISCARD,      (*  5 *)
                  LMEM__ZEROINIT,       (*  6 *)
                  LMEM__MODIFY,         (*  7 *)
                  LMEM__DISCARDABLE_8,  (*  8 *)
                  LMEM__DISCARDABLE_9,  (*  8 *)
                  LMEM__DISCARDABLE_10, (*  8 *)
                  LMEM__DISCARDABLE_11, (*  8 *)
                  LMEM__12,             (* 12 *)
                  LMEM__13,             (* 13 *)
                  LMEM__DISCARDED,      (* 14 *)
                  LMEM__INVALID_HANDLE);(* 15 *)

TYPE LMEM_SET = SET OF LMEM_ENUM;

CONST LMEM_FIXED          = LMEM_SET {};                     (* 0x0000 *)
      LMEM_MOVEABLE       = LMEM_SET {LMEM__MOVEABLE};       (* 0x0002 *)
      LMEM_NOCOMPACT      = LMEM_SET {LMEM__NOCOMPACT};      (* 0x0010 *)
      LMEM_NODISCARD      = LMEM_SET {LMEM__NODISCARD};      (* 0x0020 *)
      LMEM_ZEROINIT       = LMEM_SET {LMEM__ZEROINIT};       (* 0x0040 *)
      LMEM_MODIFY         = LMEM_SET {LMEM__MODIFY};         (* 0x0080 *)
      LMEM_DISCARDABLE    = LMEM_SET {LMEM__DISCARDABLE_8..
                                      LMEM__DISCARDABLE_11}; (* 0x0100 *)
      LMEM_INVALID_HANDLE = LMEM_SET {LMEM__INVALID_HANDLE}; (* 0x8000 *)

      LMEM_VALID_FLAGS    = LMEM_MOVEABLE  +
                            LMEM_NOCOMPACT +
                            LMEM_NODISCARD +
                            LMEM_ZEROINIT  +
                            LMEM_MODIFY    +
                            LMEM_DISCARDABLE; (* 0x0F72 *)

      LHND                = LMEM_MOVEABLE + LMEM_ZEROINIT;
      LPTR                = LMEM_FIXED + LMEM_ZEROINIT;

      NONZEROLHND         = LMEM_MOVEABLE;
      NONZEROLPTR         = LMEM_FIXED;

PROCEDURE LocalDiscard (h : HLOCAL) : HLOCAL; (* was a macro; now in RTL *)

(* Flags returned by LocalFlags (in addition to LMEM_DISCARDABLE) *)

CONST LMEM_DISCARDED = LMEM_SET {LMEM__DISCARDED}; (* 0x4000 *)
      LMEM_LOCKCOUNT = SYSTEM.CAST (LMEM_SET, VAL (DWORD, 00FFh));

(* dwCreationFlag values *)

TYPE CREATE_ENUM = (CREATE__0,  CREATE__1,  CREATE__2,  CREATE__3,
                    CREATE__4,  CREATE__5,  CREATE__6,  CREATE__7,
                    CREATE__8,  CREATE__9,  CREATE__10, CREATE__11,
                    CREATE__12, CREATE__13, CREATE__14, CREATE__15,
                    CREATE__16, CREATE__17, CREATE__18, CREATE__19,
                    CREATE__20, CREATE__21, CREATE__22, CREATE__23,
                    CREATE__24, CREATE__25, CREATE__26, CREATE__27,
                    CREATE__28, CREATE__29, CREATE__30);

     CREATE_SET = SET OF CREATE_ENUM;
     PRIORITY_CLASS = CREATE_SET;

CONST DEBUG_PROCESS               = CREATE_SET {CREATE__0}; (* 00000001h *)
      DEBUG_ONLY_THIS_PROCESS     = CREATE_SET {CREATE__1}; (* 00000002h *)

      CREATE_SUSPENDED            = CREATE_SET {CREATE__2}; (* 00000004h *)

      DETACHED_PROCESS            = CREATE_SET {CREATE__3}; (* 00000008h *)

      CREATE_NEW_CONSOLE          = CREATE_SET {CREATE__4}; (* 00000010h *)

      NORMAL_PRIORITY_CLASS       = PRIORITY_CLASS {CREATE__5}; (* 00000020h *)
      IDLE_PRIORITY_CLASS         = PRIORITY_CLASS {CREATE__6}; (* 00000040h *)
      HIGH_PRIORITY_CLASS         = PRIORITY_CLASS {CREATE__7}; (* 00000080h *)
      REALTIME_PRIORITY_CLASS     = PRIORITY_CLASS {CREATE__8}; (* 00000100h *)

      CREATE_NEW_PROCESS_GROUP    = CREATE_SET {CREATE__9};     (* 00000200h *)
      CREATE_UNICODE_ENVIRONMENT  = CREATE_SET {CREATE__10};    (* 00000400h *)

      CREATE_SEPARATE_WOW_VDM     = CREATE_SET {CREATE__11};    (* 00000800h *)
      CREATE_SHARED_WOW_VDM       = CREATE_SET {CREATE__12};    (* 00001000h *)
      CREATE_FORCEDOS             = CREATE_SET {CREATE__13};    (* 00002000h *)

      CREATE_DEFAULT_ERROR_MODE   = CREATE_SET {CREATE__26};    (* 04000000h *)
      CREATE_NO_WINDOW            = CREATE_SET {CREATE__27};    (* 08000000h *)

      PROFILE_USER                = CREATE_SET {CREATE__28};    (* 10000000h *)
      PROFILE_KERNEL              = CREATE_SET {CREATE__29};    (* 20000000h *)
      PROFILE_SERVER              = CREATE_SET {CREATE__30};    (* 40000000h *)


CONST THREAD_PRIORITY_LOWEST        = THREAD_BASE_PRIORITY_MIN;
      THREAD_PRIORITY_BELOW_NORMAL  = THREAD_PRIORITY_LOWEST + 1;
      THREAD_PRIORITY_NORMAL        = 0;
      THREAD_PRIORITY_HIGHEST       = THREAD_BASE_PRIORITY_MAX;
      THREAD_PRIORITY_ABOVE_NORMAL  = THREAD_PRIORITY_HIGHEST - 1;
      THREAD_PRIORITY_ERROR_RETURN  = MAX (LONG);

      THREAD_PRIORITY_TIME_CRITICAL = THREAD_BASE_PRIORITY_LOWRT;
      THREAD_PRIORITY_IDLE          = THREAD_BASE_PRIORITY_IDLE;

(* Debug APIs *)

TYPE DEBUG_EVENT_TYPE = (DEBUG_EVENT_0,
                         EXCEPTION_DEBUG_EVENT,       (* 1 *)
                         CREATE_THREAD_DEBUG_EVENT,   (* 2 *)
                         CREATE_PROCESS_DEBUG_EVENT,  (* 3 *)
                         EXIT_THREAD_DEBUG_EVENT,     (* 4 *)
                         EXIT_PROCESS_DEBUG_EVENT,    (* 5 *)
                         LOAD_DLL_DEBUG_EVENT,        (* 6 *)
                         UNLOAD_DLL_DEBUG_EVENT,      (* 7 *)
                         OUTPUT_DEBUG_STRING_EVENT,   (* 8 *)
                         RIP_EVENT);                  (* 9 *)

TYPE EXCEPTION_DEBUG_INFO =
     RECORD
           ExceptionRecord : EXCEPTION_RECORD;
           dwFirstChance : DWORD;
     END;
     PEXCEPTION_DEBUG_INFO = POINTER TO EXCEPTION_DEBUG_INFO;

TYPE CREATE_THREAD_DEBUG_INFO =
     RECORD
            hThread : HANDLE;
            lpThreadLocalBase : PVOID;
            lpStartAddress: PTHREAD_START_ROUTINE;
     END;
     PCREATE_THREAD_DEBUG_INFO = POINTER TO CREATE_THREAD_DEBUG_INFO;

TYPE CREATE_PROCESS_DEBUG_INFO =
     RECORD
            hFile                 : HANDLE;
            hProcess              : HANDLE;
            hThread               : HANDLE;
            lpBaseOfImage         : PVOID;
            dwDebugInfoFileOffset : DWORD;
            nDebugInfoSize        : DWORD;
            lpThreadLocalBase     : PVOID;
            lpStartAddress        : PTHREAD_START_ROUTINE;
            lpImageName           : PVOID;
            fUnicode              : WORD;
     END;
     PCREATE_PROCESS_DEBUG_INFO = POINTER TO CREATE_PROCESS_DEBUG_INFO;

TYPE EXIT_THREAD_DEBUG_INFO = RECORD
                                     dwExitCode : DWORD;
                              END;
    PEXIT_THREAD_DEBUG_INFO = POINTER TO EXIT_THREAD_DEBUG_INFO;

TYPE EXIT_PROCESS_DEBUG_INFO = RECORD
                                      dwExitCode : DWORD;
                               END;
    PEXIT_PROCESS_DEBUG_INFO = POINTER TO EXIT_PROCESS_DEBUG_INFO;

TYPE LOAD_DLL_DEBUG_INFO = RECORD
                                  hFile                 : HANDLE;
                                  lpBaseOfDll           : PVOID;
                                  dwDebugInfoFileOffset : DWORD;
                                  nDebugInfoSize        : DWORD;
                                  lpImageName           : PVOID;
                                  fUnicode              : WORD;
                           END;
   PLOAD_DLL_DEBUG_INFO = POINTER TO LOAD_DLL_DEBUG_INFO;

TYPE UNLOAD_DLL_DEBUG_INFO = RECORD
                                    lpBaseOfDll : PVOID;
                             END;
    PUNLOAD_DLL_DEBUG_INFO = POINTER TO UNLOAD_DLL_DEBUG_INFO;

TYPE OUTPUT_DEBUG_STRING_INFO = RECORD
                                       lpDebugStringData  : PSTR;
                                       fUnicode           : WORD;
                                       nDebugStringLength : WORD;
     END;
    POUTPUT_DEBUG_STRING_INFO = POINTER TO OUTPUT_DEBUG_STRING_INFO;

(*
 * SetLastErrorEx() and RIP_INFO types.
 *)

TYPE SLE_ENUM = (SLE_0,
                 SLE_ERROR,       (* 1 *)
                 SLE_MINORERROR,  (* 2 *)
                 SLE_WARNING);    (* 3 *)

TYPE RIP_INFO = RECORD
                       dwError : DWORD;
                       dwType  : SLE_ENUM;
                END;
    PRIP_INFO = POINTER TO RIP_INFO;

TYPE DEBUG_EVENT =
     RECORD
           dwDebugEventCode : DEBUG_EVENT_TYPE;
           dwProcessId      : DWORD;
           dwThreadId       : DWORD;
           CASE : DEBUG_EVENT_TYPE OF
           | EXCEPTION_DEBUG_EVENT      : Exception         : EXCEPTION_DEBUG_INFO;
           | CREATE_THREAD_DEBUG_EVENT  : CreateThread      : CREATE_THREAD_DEBUG_INFO;
           | CREATE_PROCESS_DEBUG_EVENT : CreateProcessInfo : CREATE_PROCESS_DEBUG_INFO;
           | EXIT_THREAD_DEBUG_EVENT    : ExitThread        : EXIT_THREAD_DEBUG_INFO;
           | EXIT_PROCESS_DEBUG_EVENT   : ExitProcess       : EXIT_PROCESS_DEBUG_INFO;
           | LOAD_DLL_DEBUG_EVENT       : LoadDll           : LOAD_DLL_DEBUG_INFO;
           | UNLOAD_DLL_DEBUG_EVENT     : UnloadDll         : UNLOAD_DLL_DEBUG_INFO;
           | OUTPUT_DEBUG_STRING_EVENT  : DebugString       : OUTPUT_DEBUG_STRING_INFO;
           | RIP_EVENT                  : RipInfo           : RIP_INFO;
           END;
     END;
     PDEBUG_EVENT = POINTER TO DEBUG_EVENT;

TYPE DRIVE_TYPE = (DRIVE_UNKNOWN,     (* 0 *)
                   DRIVE_NO_ROOT_DIR, (* 1 *)
                   DRIVE_REMOVABLE,   (* 2 *)
                   DRIVE_FIXED,       (* 3 *)
                   DRIVE_REMOTE,      (* 4 *)
                   DRIVE_CDROM,       (* 5 *)
                   DRIVE_RAMDISK);    (* 6 *)

(* File types are actually enumeration types; they are represented as set
   values for sole reason that one bit (8000) is allocated for REMOTE flag,
   and should be masked out using set operations
*)

TYPE FILE_TYPE_ENUM = (FILE_TYPE_0,  FILE_TYPE_1,  FILE_TYPE_2,  FILE_TYPE_3,
                       FILE_TYPE_4,  FILE_TYPE_5,  FILE_TYPE_6,  FILE_TYPE_7,
                       FILE_TYPE_8,  FILE_TYPE_9,  FILE_TYPE_10, FILE_TYPE_11,
                       FILE_TYPE_12, FILE_TYPE_13, FILE_TYPE_14,
                       FILE_TYPE__REMOTE); (* 15 *)

TYPE FILE_TYPE = SET OF FILE_TYPE_ENUM;

CONST FILE_TYPE_UNKNOWN = FILE_TYPE {};                         (* 0000h *)
      FILE_TYPE_DISK    = FILE_TYPE {FILE_TYPE_0};              (* 0001h *)
      FILE_TYPE_CHAR    = FILE_TYPE {FILE_TYPE_1};              (* 0002h *)
      FILE_TYPE_PIPE    = FILE_TYPE {FILE_TYPE_1, FILE_TYPE_0}; (* 0003h *)
      FILE_TYPE_REMOTE  = FILE_TYPE {FILE_TYPE__REMOTE};        (* 8000h *)

TYPE STD_HANDLE_TYPE = DWORD;

CONST STD_INPUT_HANDLE  = SYSTEM.CAST (STD_HANDLE_TYPE, VAL (LONG, -10));
      STD_OUTPUT_HANDLE = SYSTEM.CAST (STD_HANDLE_TYPE, VAL (LONG, -11));
      STD_ERROR_HANDLE  = SYSTEM.CAST (STD_HANDLE_TYPE, VAL (LONG, -12));

CONST IGNORE            = 0;           (* Ignore signal *)
      INFINITE          = 0FFFFFFFFh;  (* Infinite timeout *)

(*
** Baud rates at which the communication device operates
*)

CONST CBR_110           = 110;
      CBR_300           = 300;
      CBR_600           = 600;
      CBR_1200          = 1200;
      CBR_2400          = 2400;
      CBR_4800          = 4800;
      CBR_9600          = 9600;
      CBR_14400         = 14400;
      CBR_19200         = 19200;
      CBR_38400         = 38400;
      CBR_56000         = 56000;
      CBR_57600         = 57600;
      CBR_115200        = 115200;
      CBR_128000        = 128000;
      CBR_256000        = 256000;

(*
** Error Flags
*)

TYPE CE_ENUM = (CE__RXOVER,         (*  0 - Receive Queue overflow *)
                CE__OVERRUN,        (*  1 - Receive Overrun Error *)
                CE__RXPARITY,       (*  2 - Receive Parity Error *)
                CE__FRAME,          (*  3 - Receive Framing error *)
                CE__BREAK,          (*  4 - Break Detected *)
                CE__5, CE__6, CE__7,
                CE__TXFULL,         (*  8 - TX Queue is full *)
                CE__PTO,            (*  9 - LPTx Timeout *)
                CE__IOE,            (* 10 - LPTx I/O Error *)
                CE__DNS,            (* 11 - LPTx Device not selected *)
                CE__OOP,            (* 12 - LPTx Out-Of-Paper *)
                CE__13, CE__14,
                CE__MODE);          (* 15 - Requested mode unsupported *)
     CE_SET = SET OF CE_ENUM;

CONST CE_RXOVER         = CE_SET {CE__RXOVER  }; (* 0x0001 *)
      CE_OVERRUN        = CE_SET {CE__OVERRUN }; (* 0x0002 *)
      CE_RXPARITY       = CE_SET {CE__RXPARITY}; (* 0x0004 *)
      CE_FRAME          = CE_SET {CE__FRAME   }; (* 0x0008 *)
      CE_BREAK          = CE_SET {CE__BREAK   }; (* 0x0010 *)
      CE_TXFULL         = CE_SET {CE__TXFULL  }; (* 0x0100 *)
      CE_PTO            = CE_SET {CE__PTO     }; (* 0x0200 *)
      CE_IOE            = CE_SET {CE__IOE     }; (* 0x0400 *)
      CE_DNS            = CE_SET {CE__DNS     }; (* 0x0800 *)
      CE_OOP            = CE_SET {CE__OOP     }; (* 0x1000 *)
      CE_MODE           = CE_SET {CE__MODE    }; (* 0x8000 *)

      IE_BADID          = -1;  (* Invalid or unsupported id *)
      IE_OPEN           = -2;  (* Device Already Open *)
      IE_NOPEN          = -3;  (* Device Not Open *)
      IE_MEMORY         = -4;  (* Unable to allocate queues *)
      IE_DEFAULT        = -5;  (* Error in default parameters *)
      IE_HARDWARE       = -10; (* Hardware Not Present *)
      IE_BYTESIZE       = -11; (* Illegal Byte Size *)
      IE_BAUDRATE       = -12; (* Unsupported BaudRate *)

(*
** Events
*)

TYPE EV_ENUM = (EV__RXCHAR,   (*  0 - Any Character received *)
                EV__RXFLAG,   (*  1 - Received certain character *)
                EV__TXEMPTY,  (*  2 - Transmitt Queue Empty *)
                EV__CTS,      (*  3 - CTS changed state *)
                EV__DSR,      (*  4 - DSR changed state *)
                EV__RLSD,     (*  5 - RLSD changed state *)
                EV__BREAK,    (*  6 - BREAK received *)
                EV__ERR,      (*  7 - Line status error occurred *)
                EV__RING,     (*  8 - Ring signal detected *)
                EV__PERR,     (*  9 - Printer error occured *)
                EV__RX80FULL, (* 10 - Receive buffer is 80 percent full *)
                EV__EVENT1,   (* 11 - Provider specific event 1 *)
                EV__EVENT2);  (* 12 - Provider specific event 2 *)

      EV_SET = SET OF EV_ENUM;

CONST EV_RXCHAR         = EV_SET {EV__RXCHAR  }; (* 0001h; *)
      EV_RXFLAG         = EV_SET {EV__RXFLAG  }; (* 0002h; *)
      EV_TXEMPTY        = EV_SET {EV__TXEMPTY }; (* 0004h; *)
      EV_CTS            = EV_SET {EV__CTS     }; (* 0008h; *)
      EV_DSR            = EV_SET {EV__DSR     }; (* 0010h; *)
      EV_RLSD           = EV_SET {EV__RLSD    }; (* 0020h; *)
      EV_BREAK          = EV_SET {EV__BREAK   }; (* 0040h; *)
      EV_ERR            = EV_SET {EV__ERR     }; (* 0080h; *)
      EV_RING           = EV_SET {EV__RING    }; (* 0100h; *)
      EV_PERR           = EV_SET {EV__PERR    }; (* 0200h; *)
      EV_RX80FULL       = EV_SET {EV__RX80FULL}; (* 0400h; *)
      EV_EVENT1         = EV_SET {EV__EVENT1  }; (* 0800h; *)
      EV_EVENT2         = EV_SET {EV__EVENT2  }; (* 1000h; *)

(*
** Escape Functions
*)

TYPE ESCAPE_TYPE = (ESCAPE_0,
                    SETXOFF,   (* 1 *)   (* Simulate XOFF received *)
                    SETXON,    (* 2 *)   (* Simulate XON received *)
                    SETRTS,    (* 3 *)   (* Set RTS high *)
                    CLRRTS,    (* 4 *)   (* Set RTS low *)
                    SETDTR,    (* 5 *)   (* Set DTR high *)
                    CLRDTR,    (* 6 *)   (* Set DTR low *)
                    RESETDEV,  (* 7 *)   (* Reset device if possible *)
                    SETBREAK,  (* 8 *)   (* Set the device break line. *)
                    CLRBREAK); (* 9 *)   (* Clear the device break line. *)

(*
** PURGE function flags.
*)

TYPE PURGE_ENUM = (PURGE__TXABORT,  (* 0 - Kill the pending/current writes to the comm port. *)
                   PURGE__RXABORT,  (* 1 - Kill the pending/current reads to the comm port. *)
                   PURGE__TXCLEAR,  (* 2 - Kill the transmit queue if there. *)
                   PURGE__RXCLEAR); (* 3 - Kill the typeahead buffer if there. *)
     PURGE_SET = SET OF PURGE_ENUM;

CONST PURGE_TXABORT     = PURGE_SET {PURGE__TXABORT}; (* 0x0001 *)
      PURGE_RXABORT     = PURGE_SET {PURGE__RXABORT}; (* 0x0002 *)
      PURGE_TXCLEAR     = PURGE_SET {PURGE__TXCLEAR}; (* 0x0004 *)
      PURGE_RXCLEAR     = PURGE_SET {PURGE__RXCLEAR}; (* 0x0008 *)

CONST LPTx              = 80h;   (* Set if ID is for LPT device *)

(*
** Modem Status Flags
*)

TYPE MS_ENUM = (MS__0, MS__1,
                MS__2, MS__3,
                MS__CTS_ON,  (* 4 *)
                MS__DSR_ON,   (* 5 *)
                MS__RING_ON,  (* 6 *)
                MS__RLSD_ON); (* 7 *)

     MS_SET = SET OF MS_ENUM;

CONST MS_CTS_ON         = MS_SET {MS__CTS_ON};  (* 0010h *)
      MS_DSR_ON         = MS_SET {MS__DSR_ON};  (* 0020h *)
      MS_RING_ON        = MS_SET {MS__RING_ON}; (* 0040h *)
      MS_RLSD_ON        = MS_SET {MS__RLSD_ON}; (* 0080h *)

(* Special timeout values for WaitNamedPipe *)

CONST NMPWAIT_WAIT_FOREVER     = 0ffffffffh;
      NMPWAIT_NOWAIT           = 000000001h;
      NMPWAIT_USE_DEFAULT_WAIT = 000000000h;


CONST FS_CASE_IS_PRESERVED      = FILE_CASE_PRESERVED_NAMES;
      FS_CASE_SENSITIVE         = FILE_CASE_SENSITIVE_SEARCH;
      FS_UNICODE_STORED_ON_DISK = FILE_UNICODE_ON_DISK;
      FS_PERSISTENT_ACLS        = FILE_PERSISTENT_ACLS;
      FS_VOL_IS_COMPRESSED      = FILE_VOLUME_IS_COMPRESSED;
      FS_FILE_COMPRESSION       = FILE_FILE_COMPRESSION;

      FILE_MAP_COPY       = SECTION_QUERY;
      FILE_MAP_WRITE      = SECTION_MAP_WRITE;
      FILE_MAP_READ       = SECTION_MAP_READ;
      FILE_MAP_ALL_ACCESS = SECTION_ALL_ACCESS;

(* OpenFIle flags *)

TYPE OF_ENUM = (OF__WRITE,            (*  0 *)
                OF__READWRITE,        (*  1 *)
                OF__2, OF__3,
                OF__SHARE_EXCLUSIVE,  (*  4 *)
                OF__SHARE_DENY_WRITE, (*  5 *)
                OF__SHARE_DENY_NONE,  (*  6 *)
                OF__7,
                OF__PARSE,            (*  8 *)
                OF__DELETE,           (*  9 *)
                OF__VERIFY,           (* 10 *)
                OF__CANCEL,           (* 11 *)
                OF__CREATE,           (* 12 *)
                OF__PROMPT,           (* 13 *)
                OF__EXIST,            (* 14 *)
                OF__REOPEN);          (* 15 *)
      OF_FLAGS = SET OF OF_ENUM;

CONST OF_READ             = OF_FLAGS {                    }; (* 00000000h; *)
      OF_WRITE            = OF_FLAGS {OF__WRITE           }; (* 00000001h; *)
      OF_READWRITE        = OF_FLAGS {OF__READWRITE       }; (* 00000002h; *)
      OF_SHARE_COMPAT     = OF_FLAGS {                    }; (* 00000000h; *)
      OF_SHARE_EXCLUSIVE  = OF_FLAGS {OF__SHARE_EXCLUSIVE }; (* 00000010h; *)
      OF_SHARE_DENY_WRITE = OF_FLAGS {OF__SHARE_DENY_WRITE}; (* 00000020h; *)
      OF_SHARE_DENY_READ  = OF_FLAGS {OF__SHARE_EXCLUSIVE,
                                      OF__SHARE_DENY_WRITE}; (* 00000030h; *)
      OF_SHARE_DENY_NONE  = OF_FLAGS {OF__SHARE_DENY_NONE }; (* 00000040h; *)
      OF_PARSE            = OF_FLAGS {OF__PARSE           }; (* 00000100h; *)
      OF_DELETE           = OF_FLAGS {OF__DELETE          }; (* 00000200h; *)
      OF_VERIFY           = OF_FLAGS {OF__VERIFY          }; (* 00000400h; *)
      OF_CANCEL           = OF_FLAGS {OF__CANCEL          }; (* 00000800h; *)
      OF_CREATE           = OF_FLAGS {OF__CREATE          }; (* 00001000h; *)
      OF_PROMPT           = OF_FLAGS {OF__PROMPT          }; (* 00002000h; *)
      OF_EXIST            = OF_FLAGS {OF__EXIST           }; (* 00004000h; *)
      OF_REOPEN           = OF_FLAGS {OF__REOPEN          }; (* 00008000h; *)

      OFS_MAXPATHNAME = 128;

TYPE OFSTRUCT = RECORD
                       cBytes     : BYTE;
                       fFixedDisk : BYTE;
                       nErrCode   : WORD;
                       Reserved1  : WORD;
                       Reserved2  : WORD;
                       szPathName : ARRAY [0..OFS_MAXPATHNAME-1] OF CHAR;
                END;
    POFSTRUCT = POINTER TO OFSTRUCT;

PROCEDURE InterlockedIncrement (VAR Addend : LONG) : LONG;
PROCEDURE InterlockedDecrement (VAR Addend : LONG) : LONG;
PROCEDURE InterlockedExchange  (VAR Target : LONG; Value : LONG) : LONG;

PROCEDURE InterlockedCompareExchange (VAR Destination : PVOID;
                                      Exchange        : PVOID;
                                      Comperand       : PVOID) : PVOID;

PROCEDURE InterlockedExchangeAdd (VAR Addend : LONG; Value : LONG) : LONG;

PROCEDURE FreeResource (hResData : HGLOBAL) : BOOL;
PROCEDURE LockResource (hResData : HGLOBAL) : PVOID;

CONST MAXINTATOM   = 0C000h;
      INVALID_ATOM = SYSTEM.CAST (ATOM, 0);

PROCEDURE MAKEINTATOM (i : INTEGER) : ATOMSTR; (* in RTL; was macro *)

(* PROCEDURE WinMain has been deleted because main module is used instead *)

PROCEDURE FreeLibrary (hLibModul : HMODULE) : BOOL;

CONST FreeModule = FreeLibrary;

PROCEDURE FreeLibraryAndExitThread (hLibModule : HMODULE;
                                    dwExitCode : DWORD);

PROCEDURE DisableThreadLibraryCalls (hLibModule : HMODULE) : BOOL;
PROCEDURE GetProcAddress (hModule    : HMODULE;
                          lpProcName : PCSTR)   (* lpProcName can receive ordinal value *)
                                              : PROC;
PROCEDURE GetVersion () : DWORD;
PROCEDURE GlobalAlloc (uFlags  : GMEM_SET;
                       dwBytes : DWORD) : HGLOBAL;

PROCEDURE GlobalReAlloc (hMem    : HGLOBAL;
                         dwBytes : DWORD;
                         uFlags  : GMEM_SET) : HGLOBAL;

PROCEDURE GlobalSize  (hMem : HGLOBAL) : DWORD;
PROCEDURE GlobalFlags (hMem : HGLOBAL) : GMEM_SET;
PROCEDURE GlobalLock  (hMem : HGLOBAL) : PVOID;

PROCEDURE GlobalHandle  (pMem : LPCVOID) : HGLOBAL;
PROCEDURE GlobalUnlock  (hMem : HGLOBAL) : BOOL;
PROCEDURE GlobalFree    (hMem : HGLOBAL) : HGLOBAL;
PROCEDURE GlobalCompact (dwMinFree : DWORD) : UINT;
PROCEDURE GlobalFix     (hMem : HGLOBAL);
PROCEDURE GlobalUnfix   (hMem : HGLOBAL);
PROCEDURE GlobalWire    (hMem : HGLOBAL) : PVOID;
PROCEDURE GlobalUnWire  (hMem : HGLOBAL) : BOOL;
PROCEDURE GlobalMemoryStatus (VAR Buffer : MEMORYSTATUS);
PROCEDURE LocalAlloc    (uFlags : LMEM_SET; uByte : UINT) : HLOCAL;
PROCEDURE LocalReAlloc  (hMem : HLOCAL; uBytes : UINT; uFlags : LMEM_SET) : HLOCAL;
PROCEDURE LocalLock     (hMem : HLOCAL) : PVOID;
PROCEDURE LocalHandle   (pMem : LPCVOID) : HLOCAL;
PROCEDURE LocalUnlock   (hMem : HLOCAL) : BOOL;
PROCEDURE LocalSize     (hMem : HLOCAL) : UINT;
PROCEDURE LocalFlags    (hMem : HLOCAL) : LMEM_SET;
PROCEDURE LocalFree     (hMem : HLOCAL) : HLOCAL;
PROCEDURE LocalShrink (hMem : HLOCAL; cbNewSize : UINT) : UINT;
PROCEDURE LocalCompact (uMinFree : UINT) : UINT;
PROCEDURE FlushInstructionCache (hProcess      : HANDLE;
                                 lpBaseAddress : LPCVOID;
                                 dwSize        : DWORD) : BOOL;

PROCEDURE VirtualAlloc (lpAddress        : PVOID;
                        dwSize           : DWORD;
                        flAllocationType : PROTECT_SET;
                        flProtect        : PROTECT_SET) : PVOID;

PROCEDURE VirtualFree (lpAddress  : LPCVOID;
                       dwSize     : DWORD;
                       dwFreeType : PROTECT_SET) : BOOL;

PROCEDURE VirtualProtect (lpAddress      : PVOID;
                          dwSize         : DWORD;
                          flNewProtect   : PROTECT_SET;
                          VAR OldProtect : PROTECT_SET) : BOOL;

PROCEDURE VirtualQuery (lpAddress  : LPCVOID;
                        VAR Buffer : MEMORY_BASIC_INFORMATION;
                        dwLength   : DWORD) : DWORD;

PROCEDURE VirtualProtectEx (hProcess       : HANDLE;
                            lpAddress      : PVOID;
                            dwSize         : DWORD;
                            flNewProtect   : PROTECT_SET;
                            VAR OldProtect : PROTECT_SET) : BOOL;

PROCEDURE VirtualQueryEx (hProcess  : HANDLE;
                          lpAddress : LPCVOID;
                          VAR Buffer: MEMORY_BASIC_INFORMATION;
                          dwLength  : DWORD) : DWORD;

PROCEDURE HeapCreate (flOptions     : HEAP_SET;
                      dwInitialSize : DWORD;
                      dwMaximumSize : DWORD) : HANDLE;

PROCEDURE HeapDestroy (hHeap : HANDLE) : BOOL;
PROCEDURE HeapAlloc   (hHeap : HANDLE; dwFlags : HEAP_SET; dwBytes : DWORD) : PVOID;
PROCEDURE HeapReAlloc (hHeap : HANDLE; dwFlags : HEAP_SET;
                       lpMem : PVOID;  dwBytes : DWORD) : PVOID;

PROCEDURE HeapFree     (hHeap : HANDLE; dwFlags : HEAP_SET; lpMem : PVOID) : BOOL;
PROCEDURE HeapSize     (hHeap : HANDLE; dwFlags : HEAP_SET; lpMem : LPCVOID) : DWORD;
PROCEDURE HeapValidate (hHeap : HANDLE; dwFlags : HEAP_SET; lpMem : LPCVOID) : BOOL;
PROCEDURE HeapCompact  (hHeap : HANDLE; dwFlags : HEAP_SET) : UINT;
PROCEDURE GetProcessHeap () : HANDLE;
PROCEDURE GetProcessHeaps (NumberOfHeaps    : DWORD;
                           VAR ProcessHeaps : ARRAY OF HANDLE) : DWORD;

(* PROCESS_HEAP_ENTRY wFlags values *)

TYPE PROCESS_HEAP_ENUM = (PROCESS_HEAP__REGION,            (* 0 *)
                          PROCESS_HEAP__UNCOMMITTED_RANGE, (* 1 *)
                          PROCESS_HEAP__ENTRY_BUSY,        (* 2 *)
                          PROCESS_HEAP__3,
                          PROCESS_HEAP__ENTRY_MOVEABLE,    (* 4 *)
                          PROCESS_HEAP__ENTRY_DDESHARE);   (* 5 *)

<* PUSH *> <* SETSIZE = "2" *>

TYPE PROCESS_HEAP_SET = SET OF PROCESS_HEAP_ENUM;

CONST PROCESS_HEAP_REGION             = PROCESS_HEAP_SET {PROCESS_HEAP__REGION};            (* 0001h *)
      PROCESS_HEAP_UNCOMMITTED_RANGE  = PROCESS_HEAP_SET {PROCESS_HEAP__UNCOMMITTED_RANGE}; (* 0002h *)
      PROCESS_HEAP_ENTRY_BUSY         = PROCESS_HEAP_SET {PROCESS_HEAP__ENTRY_BUSY};        (* 0004h *)
      PROCESS_HEAP_ENTRY_MOVEABLE     = PROCESS_HEAP_SET {PROCESS_HEAP__ENTRY_MOVEABLE};    (* 0010h *)
      PROCESS_HEAP_ENTRY_DDESHARE     = PROCESS_HEAP_SET {PROCESS_HEAP__ENTRY_DDESHARE};    (* 0020h *)

<* POP *>

TYPE PROCESS_HEAP_ENTRY =
          RECORD
                 lpData       : PVOID;
                 cbData       : DWORD;
                 cbOverhead   : BYTE;
                 iRegionIndex : BYTE;
                 wFlags       : PROCESS_HEAP_SET;
                 CASE : BOOLEAN OF
                 | TRUE  : Block : RECORD
                                         hMem : HANDLE;
                                         dwReserved : ARRAY [0..2] OF DWORD;
                                   END;
                 | FALSE : Region : RECORD
                                         dwCommittedSize   : DWORD;
                                         dwUnCommittedSize : DWORD;
                                         lpFirstBlock      : PVOID;
                                         lpLastBlock       : PVOID;
                                    END;
                 END;
          END;
    PPROCESS_HEAP_ENTRY = POINTER TO PROCESS_HEAP_ENTRY;

PROCEDURE HeapLock   (hHeap : HANDLE) : BOOL;
PROCEDURE HeapUnlock (hHeap : HANDLE) : BOOL;
PROCEDURE HeapWalk   (hHeap : HANDLE; VAR Entry : PROCESS_HEAP_ENTRY) : BOOL;

(* GetBinaryType return values. *)

TYPE SCS_TYPE = (SCS_32BIT_BINARY,  (* 0 *)
                 SCS_DOS_BINARY,    (* 1 *)
                 SCS_WOW_BINARY,    (* 2 *)
                 SCS_PIF_BINARY,    (* 3 *)
                 SCS_POSIX_BINARY,  (* 4 *)
                 SCS_OS216_BINARY); (* 5 *)

PROCEDURE GetBinaryTypeA (ApplicationName : ARRAY OF CHAR;
                          VAR BinaryType  : SCS_TYPE) : BOOL;


PROCEDURE GetBinaryTypeW (ApplicationName : ARRAY OF WCHAR;
                          VAR BinaryType  : SCS_TYPE) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetBinaryType = GetBinaryTypeW;
<* ELSE *>
      CONST GetBinaryType = GetBinaryTypeA;
<* END *>

PROCEDURE GetShortPathNameA (LongPath      : ARRAY OF CHAR;
                             VAR ShortPath : ARRAY OF CHAR;
                             cchBuffer     : DWORD) : DWORD;

PROCEDURE GetShortPathNameW (LongPath      : ARRAY OF WCHAR;
                             VAR ShortPath : ARRAY OF WCHAR;
                             cchBuffer     : DWORD) : DWORD;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetShortPathName = GetShortPathNameW;
<* ELSE *>
      CONST GetShortPathName = GetShortPathNameA;
<* END *>

PROCEDURE GetProcessAffinityMask (hProcess                : HANDLE;
                                  VAR ProcessAffinityMask : BITSET;
                                  VAR SystemAffinityMask  : BITSET) : BOOL;

PROCEDURE GetProcessTimes (hProcess         : HANDLE;
                           VAR CreationTime : FILETIME;
                           VAR ExitTime     : FILETIME;
                           VAR KernelTime   : FILETIME;
                           VAR UserTime     : FILETIME) : BOOL;

PROCEDURE GetProcessWorkingSetSize (hProcess                  : HANDLE;
                                    VAR MinimumWorkingSetSize : DWORD;
                                    VAR MaximumWorkingSetSize : DWORD) : BOOL;

PROCEDURE SetProcessWorkingSetSize (hProcess                : HANDLE;
                                    dwMinimumWorkingSetSize : DWORD;
                                    dwMaximumWorkingSetSize : DWORD) : BOOL;

PROCEDURE OpenProcess (dwDesiredAccess : ACCESS_MASK;
                       bInheritHandle  : BOOL;
                       dwProcessId     : DWORD) : HANDLE;

PROCEDURE GetCurrentProcess () : HANDLE;
PROCEDURE GetCurrentProcessId () : DWORD;
PROCEDURE ExitProcess (uExitCode : UINT);
PROCEDURE TerminateProcess (hProcess : HANDLE; uExitCode : UINT) : BOOL;
PROCEDURE GetExitCodeProcess (hProcess : HANDLE; VAR ExitCode : DWORD) : BOOL;
PROCEDURE FatalExit (ExitCode : INTEGER);

PROCEDURE GetEnvironmentStringsA () : PSTR;
PROCEDURE GetEnvironmentStringsW () : PWSTR;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetEnvironmentStrings = GetEnvironmentStringsW;
<* ELSE *>
      CONST GetEnvironmentStrings = GetEnvironmentStringsA;
<* END *>

PROCEDURE FreeEnvironmentStringsA (str :  PSTR) : BOOL;
PROCEDURE FreeEnvironmentStringsW (str : PWSTR) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST FreeEnvironmentStrings = FreeEnvironmentStringsW;
<* ELSE *>
      CONST FreeEnvironmentStrings = FreeEnvironmentStringsA;
<* END *>

PROCEDURE RaiseException (dwExceptionCode    : DWORD;
                          dwExceptionFlags   : DWORD; (* only EXCEPTION_NONCONTINUABLE allowed *)
                          nNumberOfArguments : DWORD;
                          lpArguments        : PCDWORD); (* actually ARRAY OF DWORD but can accept NIL *)

PROCEDURE UnhandledExceptionFilter (VAR ExceptionInfo : EXCEPTION_POINTERS) : LONG;

TYPE PTOP_LEVEL_EXCEPTION_FILTER = PROCEDURE (
        VAR (* ExceptionInfo : *) EXCEPTION_POINTERS) : LONG;


PROCEDURE SetUnhandledExceptionFilter (
                    TopLevelExceptionFilter : PTOP_LEVEL_EXCEPTION_FILTER
          ) : PTOP_LEVEL_EXCEPTION_FILTER;

PROCEDURE CreateFiber (dwStackSize    : DWORD;
                       lpStartAddress : PFIBER_START_ROUTINE;
                       lpParameter    : PVOID)
                                               : PVOID;

PROCEDURE DeleteFiber (lpFiber : PVOID);
PROCEDURE ConvertThreadToFiber (lpParameter : PVOID) : PVOID;
PROCEDURE SwitchToFiber (lpFiber : PVOID);
PROCEDURE SwitchToThread () : BOOL;

PROCEDURE CreateThread (lpThreadAttributes : PSECURITY_ATTRIBUTES;  (* IN NIL *)
                        dwStackSize        : DWORD;
                        lpStartAddress     : PTHREAD_START_ROUTINE;
                        lpParameter        : PVOID;
                        dwCreationFlags    : CREATE_SET;
                        VAR ThreadId       : DWORD) : HANDLE;

PROCEDURE CreateRemoteThread (hProcess           : HANDLE;
                              lpThreadAttributes : PSECURITY_ATTRIBUTES;  (* IN NIL *)
                              dwStackSize        : DWORD;
                              lpStartAddress     : PTHREAD_START_ROUTINE;
                              lpParameter        : PVOID;
                              dwCreationFlags    : CREATE_SET;
                              VAR [NIL] ThreadId : DWORD) : HANDLE;

PROCEDURE GetCurrentThread   (): HANDLE;
PROCEDURE GetCurrentThreadId () : DWORD;
PROCEDURE SetThreadAffinityMask (hThread              : HANDLE;
                                 dwThreadAffinityMask : BITSET) : BITSET;

PROCEDURE SetThreadIdealProcessor (hThread          : HANDLE;
                                   dwIdealProcessor : DWORD) : DWORD;

PROCEDURE SetProcessPriorityBoost (hProcess             : HANDLE;
                                   DisablePriorityBoost : BOOL) : BOOL;

PROCEDURE GetProcessPriorityBoost (hProcess                 : HANDLE;
                                   VAR DisablePriorityBoost : BOOL) : BOOL;

PROCEDURE SetThreadPriority (hThread   : HANDLE;
                             nPriority : INTEGER) : BOOL;

PROCEDURE SetThreadPriorityBoost (hThread               : HANDLE;
                                  bDisablePriorityBoost : BOOL) : BOOL;

PROCEDURE GetThreadPriorityBoost (hThread                  : HANDLE;
                                  VAR DisablePriorityBoost : BOOL) : BOOL;

PROCEDURE GetThreadPriority (hThread : HANDLE) : INTEGER;

PROCEDURE GetThreadTimes (hThread          : HANDLE;
                          VAR CreationTime : FILETIME;
                          VAR ExitTime     : FILETIME;
                          VAR KernelTime   : FILETIME;
                          VAR UserTime     : FILETIME) : BOOL;

PROCEDURE ExitThread (dwExitCode : DWORD);
PROCEDURE TerminateThread (hThread : HANDLE; dwExitCode : DWORD) : BOOL;
PROCEDURE GetExitCodeThread (hThread : HANDLE; VAR ExitCode : DWORD) : BOOL;
PROCEDURE GetThreadSelectorEntry (hThread : HANDLE; dwSelector : DWORD;
                                  VAR SelectorEntry : LDT_ENTRY) : BOOL;
PROCEDURE GetLastError () : DWORD;
PROCEDURE SetLastError (dwErrCode : DWORD);

PROCEDURE HasOverlappedIoCompleted (VAR Overlapped : OVERLAPPED) : BOOL; (* IN RTL *)

PROCEDURE GetOverlappedResult (hFile                        : HANDLE;
                               VAR Overlapped               : OVERLAPPED;
                               VAR NumberOfBytesTransferred : DWORD;
                               bWait                        : BOOL)
                                                                    : BOOL;

PROCEDURE CreateIoCompletionPort (FileHandle                : HANDLE;
                                  ExistingCompletionPort    : HANDLE;
                                  CompletionKey             : DWORD;
                                  NumberOfConcurrentThreads : DWORD) : HANDLE;

PROCEDURE GetQueuedCompletionStatus (CompletionPort           : HANDLE;
                                     NumberOfBytesTransferred : DWORD;
                                     VAR CompletionKey        : DWORD;
                                     VAR Overlapped           : OVERLAPPED;
                                     dwMilliseconds           : DWORD)
                                                                       : BOOL;

PROCEDURE PostQueuedCompletionStatus (CompletionPort             : HANDLE;
                                      dwNumberOfBytesTransferred : DWORD;
                                      dwCompletionKey            : DWORD;
                                      VAR Overlapped             : OVERLAPPED) : BOOL;

TYPE SEM_ENUM = (SEM__FAILCRITICALERRORS,      (* 0 *)
                 SEM__NOGPFAULTERRORBOX,       (* 1 *)
                 SEM__NOALIGNMENTFAULTEXCEPT,  (* 2 *)
                 SEM__3,  SEM__4,  SEM__5,
                 SEM__6,  SEM__7,  SEM__8,
                 SEM__9,  SEM__10, SEM__11,
                 SEM__12, SEM__13, SEM__14,
                 SEM__NOOPENFILEERRORBOX);     (* 15 *)
     SEM_SET = SET OF SEM_ENUM;

CONST SEM_FAILCRITICALERRORS     = SEM_SET {SEM__FAILCRITICALERRORS};     (* 0x0001 *)
      SEM_NOGPFAULTERRORBOX      = SEM_SET {SEM__NOGPFAULTERRORBOX};      (* 0x0002 *)
      SEM_NOALIGNMENTFAULTEXCEPT = SEM_SET {SEM__NOALIGNMENTFAULTEXCEPT}; (* 0x0004 *)
      SEM_NOOPENFILEERRORBOX     = SEM_SET {SEM__NOOPENFILEERRORBOX};     (* 0x8000 *)

PROCEDURE SetErrorMode (uMode : SEM_SET) : SEM_SET;

PROCEDURE ReadProcessMemory (hProcess                    : HANDLE;
                             lpBaseAddress               : LPCVOID;
                             lpBuffer                    : PVOID;
                             nSize                       : DWORD;
                             VAR [NIL] NumberOfBytesRead : DWORD) : BOOL;

PROCEDURE WriteProcessMemory (hProcess                       : HANDLE;
                              lpBaseAddress                  : PVOID;
                              lpBuffer                       : PVOID;
                              nSize                          : DWORD;
                              VAR [NIL] NumberOfBytesWritten : DWORD) : BOOL;

PROCEDURE GetThreadContext (hThread : HANDLE; VAR Context : CONTEXT) : BOOL;
<* IF BACKEND # "C" THEN *>
PROCEDURE SetThreadContext (hThread : HANDLE; Context : CONTEXT) : BOOL;
<* ELSE *>
PROCEDURE SetThreadContext (hThread : HANDLE; Context : PCONTEXT) : BOOL;
<* END *> (*!*)

PROCEDURE SuspendThread (hThread : HANDLE) : DWORD;
PROCEDURE ResumeThread  (hThread : HANDLE) : DWORD;

TYPE PAPCFUNC = PROCEDURE ((* dwParam : *) DWORD);

PROCEDURE QueueUserAPC (pfnAPC  : PAPCFUNC;
                        hThread : HANDLE;
                        dwData  : DWORD) : DWORD;

PROCEDURE DebugBreak;

PROCEDURE DebugBreakProcess(hProcess : HANDLE) : BOOL;

PROCEDURE WaitForDebugEvent (VAR DebugEvent : DEBUG_EVENT;
                             dwMilliseconds : DWORD)
                                                     : BOOL;

PROCEDURE ContinueDebugEvent (dwProcessId      : DWORD;
                              dwThreadId       : DWORD;
                              dwContinueStatus : DWORD) : BOOL;

PROCEDURE DebugActiveProcess (dwProcessId : DWORD) : BOOL;
PROCEDURE InitializeCriticalSection (VAR CriticalSection : CRITICAL_SECTION);
PROCEDURE EnterCriticalSection      (VAR CriticalSection : CRITICAL_SECTION);
PROCEDURE LeaveCriticalSection      (VAR CriticalSection : CRITICAL_SECTION);
PROCEDURE TryEnterCriticalSection   (VAR CriticalSection : CRITICAL_SECTION);
PROCEDURE DeleteCriticalSection     (VAR CriticalSection : CRITICAL_SECTION);
PROCEDURE SetEvent   (hEvent : HANDLE) : BOOL;
PROCEDURE ResetEvent (hEvent : HANDLE) : BOOL;
PROCEDURE PulseEvent (hEvent : HANDLE) : BOOL;
PROCEDURE ReleaseSemaphore (hSemaphore              : HANDLE;
                            lReleaseCount           : LONG;
                            VAR [NIL] PreviousCount : LONG) : BOOL;

PROCEDURE ReleaseMutex (hMutex : HANDLE) : BOOL;
PROCEDURE WaitForSingleObject (hHandle        : HANDLE;
                               dwMilliseconds : DWORD) : DWORD;

PROCEDURE WaitForMultipleObjects (nCount         : DWORD;
                                  Handles        : ARRAY OF HANDLE;
                                  bWaitAll       : BOOL;
                                  dwMilliseconds : DWORD) : DWORD;

PROCEDURE Sleep (dwMilliseconds : DWORD);

PROCEDURE LoadResource (hModule  : HMODULE;
                        hResInfo : HRSRC) : HGLOBAL;

PROCEDURE SizeofResource (hModule  : HMODULE;
                          hResInfo : HRSRC) : DWORD;

PROCEDURE GlobalDeleteAtom (nAtom : ATOM) : ATOM;
PROCEDURE InitAtomTable    (nSize : DWORD) : BOOL;
PROCEDURE DeleteAtom       (nAtom : ATOM) : ATOM;
PROCEDURE SetHandleCount   (uNumber : UINT) : UINT;
PROCEDURE GetLogicalDrives () : BITSET;
PROCEDURE LockFile (hFile                    : HANDLE;
                    dwFileOffsetLow          : DWORD;
                    dwFileOffsetHigh         : DWORD;
                    nNumberOfBytesToLockLow  : DWORD;
                    nNumberOfBytesToLockHigh : DWORD) : BOOL;

PROCEDURE UnlockFile (hFile                      : HANDLE;
                      dwFileOffsetLow            : DWORD;
                      dwFileOffsetHigh           : DWORD;
                      nNumberOfBytesToUnlockLow  : DWORD;
                      nNumberOfBytesToUnlockHigh : DWORD) : BOOL;

TYPE LOCKFILE_ENUM = (LOCKFILE__FAIL_IMMEDIATELY,         (* 0 *)
                      LOCKFILE__EXCLUSIVE_LOCK);          (* 1 *)

     LOCKFILE_SET = SET OF LOCKFILE_ENUM;

CONST LOCKFILE_FAIL_IMMEDIATELY = LOCKFILE_SET {LOCKFILE__FAIL_IMMEDIATELY}; (* 0x00000001 *)
      LOCKFILE_EXCLUSIVE_LOCK   = LOCKFILE_SET {LOCKFILE__EXCLUSIVE_LOCK};   (* 0x00000002 *)

PROCEDURE LockFileEx (hFile                    : HANDLE;
                      dwFlags                  : LOCKFILE_SET;
                      dwReserved               : DWORD;
                      nNumberOfBytesToLockLow  : DWORD;
                      nNumberOfBytesToLockHigh : DWORD;
                      VAR Overlapped           : OVERLAPPED) : BOOL;

PROCEDURE UnlockFileEx (hFile                      : HANDLE;
                        dwReserved                 : DWORD;
                        nNumberOfBytesToUnlockLow  : DWORD;
                        nNumberOfBytesToUnlockHigh : DWORD;
                        VAR Overlapped             : OVERLAPPED) : BOOL;

TYPE BY_HANDLE_FILE_INFORMATION = RECORD
                                         dwFileAttributes     : FILE_ATTRIBUTE_SET;
                                         ftCreationTime       : FILETIME;
                                         ftLastAccessTime     : FILETIME;
                                         ftLastWriteTime      : FILETIME;
                                         dwVolumeSerialNumber : DWORD;
                                         nFileSizeHigh        : DWORD;
                                         nFileSizeLow         : DWORD;
                                         nNumberOfLinks       : DWORD;
                                         nFileIndexHigh       : DWORD;
                                         nFileIndexLow        : DWORD;
                                  END;
    PBY_HANDLE_FILE_INFORMATION = POINTER TO BY_HANDLE_FILE_INFORMATION;

PROCEDURE GetFileInformationByHandle (hFile : HANDLE;
                                      VAR FileInformation : BY_HANDLE_FILE_INFORMATION) : BOOL;

PROCEDURE GetFileType  (hFile : HANDLE) : FILE_TYPE;
PROCEDURE GetFileSize  (hFile : HANDLE; VAR [NIL] FileSizeHigh : DWORD) : DWORD;
PROCEDURE GetStdHandle (nStdHandle : STD_HANDLE_TYPE) : HANDLE;
PROCEDURE SetStdHandle (nStdHandle : STD_HANDLE_TYPE;
                        hHandle    : HANDLE)
                                             : BOOL;

PROCEDURE WriteFile (hFile                          : HANDLE;
                     lpBuffer                       : LPCVOID;
                     nNumberOfBytesToWrite          : DWORD;
                     VAR [NIL] NumberOfBytesWritten : DWORD;
                     VAR [NIL] Overlapped           : OVERLAPPED) : BOOL;

PROCEDURE ReadFile (hFile                       : HANDLE;
                    lpBuffer                    : PVOID;
                    nNumberOfBytesToRead        : DWORD;
                    VAR [NIL] NumberOfBytesRead : DWORD;
                    VAR [NIL] Overlapped        : OVERLAPPED) : BOOL;

PROCEDURE FlushFileBuffers (hFile : HANDLE) : BOOL;

PROCEDURE DeviceIoControl (hDevice                 : HANDLE;
                           dwIoControlCode         : DWORD;
                           lpInBuffer              : PVOID;
                           nInBufferSize           : DWORD;
                           lpOutBuffer             : PVOID;
                           nOutBufferSize          : DWORD;
                           VAR [NIL] BytesReturned : DWORD;
                           VAR [NIL] Overlapped    : OVERLAPPED) : BOOL;

PROCEDURE SetEndOfFile (hFile : HANDLE) : BOOL;

PROCEDURE SetFilePointer (hFile                        : HANDLE;
                          DistanceToMove               : LONG;
                          VAR [NIL] DistanceToMoveHigh : LONG;
                          dwMoveMethod                 : MOVE_TYPE)
                                                                    : DWORD;

PROCEDURE FindClose (hFindFile : HANDLE) : BOOL;

PROCEDURE GetFileTime (hFile                    : HANDLE;
                       VAR [NIL] CreationTime   : FILETIME;
                       VAR [NIL] LastAccessTime : FILETIME;
                       VAR [NIL] LastWriteTim   : FILETIME) : BOOL;

PROCEDURE SetFileTime (hFile            : HANDLE;
                       lpCreationTime   : PFILETIME;  (* IN NIL *)
                       lpLastAccessTime : PFILETIME;  (* IN NIL *)
                       lpLastWriteTime  : PFILETIME)  (* IN NIL *)
                                                     : BOOL;

PROCEDURE CloseHandle (hObject : HANDLE) : BOOL;
PROCEDURE DuplicateHandle (hSourceProcessHandle   : HANDLE;
                           hSourceHandle          : HANDLE;
                           hTargetProcessHandle   : HANDLE;
                           VAR [NIL] TargetHandle : HANDLE;
                           dwDesiredAccess        : ACCESS_MASK;
                           bInheritHandle         : BOOL;
                           dwOptions              : DUPLICATE_TYPE) : BOOL;

TYPE HANDLE_FLAG_ENUM = (HANDLE_FLAG__INHERIT,             (* 0x00000001 *)
                         HANDLE_FLAG__PROTECT_FROM_CLOSE); (* 0x00000002 *)
     HANDLE_FLAG_SET = SET OF HANDLE_FLAG_ENUM;

CONST HANDLE_FLAG_INHERIT            = HANDLE_FLAG_SET {HANDLE_FLAG__INHERIT};            (* 0x00000001 *)
      HANDLE_FLAG_PROTECT_FROM_CLOSE = HANDLE_FLAG_SET {HANDLE_FLAG__PROTECT_FROM_CLOSE}; (* 0x00000002 *)

PROCEDURE GetHandleInformation (hObject   : HANDLE;
                                VAR Flags : HANDLE_FLAG_SET) : BOOL;

PROCEDURE SetHandleInformation (hObject : HANDLE;
                                dwMask  : HANDLE_FLAG_SET;
                                dwFlags : HANDLE_FLAG_SET) : BOOL;

CONST HINSTANCE_ERROR = 32;

PROCEDURE LoadModule (ModuleName       : ARRAY OF CHAR;
                      lpParameterBlock : PVOID)
                                                : DWORD;

PROCEDURE WinExec (CmdLine : ARRAY OF CHAR; uCmdShow : UINT) : UINT; (* CmdShow is actually SW_ENUM *)
PROCEDURE ClearCommBreak (hFile : HANDLE) : BOOL;

PROCEDURE ClearCommError (hFile          : HANDLE;
                          VAR Errors     : CE_SET;
                          VAR [NIL] Stat : COMSTAT) : BOOL;

PROCEDURE SetupComm (hFile      : HANDLE;
                     dwInQueue  : DWORD;
                     dwOutQueue : DWORD) : BOOL;

PROCEDURE EscapeCommFunction (hFile  : HANDLE;
                              dwFunc : ESCAPE_TYPE) : BOOL;

PROCEDURE GetCommConfig (hCommDev : HANDLE;
                         VAR CC   : COMMCONFIG;
                         VAR Size : DWORD) : BOOL;

PROCEDURE GetCommMask (hFile       : HANDLE;
                       VAR EvtMask : EV_SET) : BOOL;

PROCEDURE GetCommProperties (hFile        : HANDLE;
                             VAR CommProp : COMMPROP) : BOOL;

PROCEDURE GetCommModemStatus (hFile         : HANDLE;
                              VAR ModemStat : MS_SET) : BOOL;

PROCEDURE GetCommState (hFile : HANDLE; VAR DCB : DCB) : BOOL;
PROCEDURE GetCommTimeouts (hFile : HANDLE; VAR CommTimeouts : COMMTIMEOUTS) : BOOL;
PROCEDURE PurgeComm (hFile : HANDLE; dwFlags : PURGE_SET) : BOOL;
PROCEDURE SetCommBreak (hFile : HANDLE) : BOOL;
<* IF BACKEND # "C" THEN *>
PROCEDURE SetCommConfig (hCommDev : HANDLE;
                         CC       : COMMCONFIG; (*!*)
                         dwSize   : DWORD) : BOOL;
<* ELSE *>
PROCEDURE SetCommConfig (hCommDev : HANDLE;
                         CC       : PCOMMCONFIG; (*!*)
                         dwSize   : DWORD) : BOOL;
<* END *>

PROCEDURE SetCommMask  (hFile : HANDLE; EvtMask : EV_SET) : BOOL;
<* IF BACKEND # "C" THEN *>
PROCEDURE SetCommState (hFile : HANDLE; DCB : DCB) : BOOL;
<* ELSE *>
PROCEDURE SetCommState (hFile : HANDLE; DCB : PDCB) : BOOL;
<* END *>  (*!*)
<* IF BACKEND # "C" THEN *>
PROCEDURE SetCommTimeouts (hFile        : HANDLE;
                           CommTimeouts : COMMTIMEOUTS) : BOOL;
<* ELSE *>
PROCEDURE SetCommTimeouts (hFile        : HANDLE;
                           CommTimeouts : PCOMMTIMEOUTS) : BOOL;
<* END *>  (*!*)

PROCEDURE TransmitCommChar (hFile : HANDLE; cChar : CHAR) : BOOL;

PROCEDURE WaitCommEvent (hFile                : HANDLE;
                         VAR EvtMask          : EV_SET;
                         VAR [NIL] Overlapped : OVERLAPPED) : BOOL;

PROCEDURE SetTapePosition (hDevice          : HANDLE;
                           dwPositionMethod : TAPE_SET_POSITION_TYPE;
                           dwPartition      : DWORD;
                           dwOffsetLow      : DWORD;
                           dwOffsetHigh     : DWORD;
                           bImmediate       : BOOL) : DWORD;

PROCEDURE GetTapePosition (hDevice              : HANDLE;
                           dwPositionType       : TAPE_GET_POSITION_TYPE;
                           VAR dwPartition      : DWORD;
                           VAR dwOffsetLow      : DWORD;
                           VAR [NIL] OffsetHigh : DWORD) : DWORD;

PROCEDURE PrepareTape (hDevice     : HANDLE;
                       dwOperation : TAPE_OPERATION;
                       bImmediate  : BOOL) : DWORD;

PROCEDURE EraseTape (hDevice     : HANDLE;
                     dwEraseType : TAPE_ERASE_TYPE;
                     bImmediate  : BOOL) : DWORD;

PROCEDURE CreateTapePartition (hDevice           : HANDLE;
                               dwPartitionMethod : TAPE_PARTITION_TYPE;
                               dwCount           : DWORD;
                               dwSize            : DWORD) : DWORD;

PROCEDURE WriteTapemark (hDevice         : HANDLE;
                         dwTapemarkType  : TAPE_MARK_TYPE;
                         dwTapemarkCount : DWORD;
                         bImmediate      : BOOL) : DWORD;

PROCEDURE GetTapeStatus (hDevice : HANDLE) : DWORD;

TYPE GET_TAPE_PARAMETERS_TYPE = (GET_TAPE_MEDIA_INFORMATION,  (* 0 *)
                                 GET_TAPE_DRIVE_INFORMATION); (* 1 *)

PROCEDURE GetTapeParameters (hDevice           : HANDLE;
                             dwOperation       : GET_TAPE_PARAMETERS_TYPE;
                             VAR Size          : DWORD;
                             lpTapeInformation : PVOID) : DWORD;

(* lpTapeInformation points to TAPE_GET_MEDIA_PARAMETERS or
   TAPE_GET_DRIVE_PARAMETERS structure depending on dwOperation *)

TYPE SET_TAPE_PARAMETERS_TYPE = (SET_TAPE_MEDIA_INFORMATION,  (* 0 *)
                                 SET_TAPE_DRIVE_INFORMATION); (* 1 *)

PROCEDURE SetTapeParameters (hDevice           : HANDLE;
                             dwOperation       : SET_TAPE_PARAMETERS_TYPE;
                             lpTapeInformation : PVOID) : DWORD;

(* lpTapeInformation points to TAPE_SET_MEDIA_PARAMETERS or
   TAPE_SET_DRIVE_PARAMETERS structure depending on dwOperation *)

PROCEDURE Beep (dwFreq : DWORD; dwDuration : DWORD) : BOOL;

PROCEDURE MulDiv (nNumber      : INTEGER;
                  nNumerator   : INTEGER;
                  nDenominator : INTEGER) : INTEGER;

PROCEDURE GetSystemTime (VAR SystemTime : SYSTEMTIME);
PROCEDURE GetSystemTimeAsFileTime (VAR SystemTimeAsFileTime : FILETIME);
<* IF BACKEND # "C" THEN *>
PROCEDURE SetSystemTime (SystemTime : SYSTEMTIME) : BOOL;
<* ELSE *>
PROCEDURE SetSystemTime (SystemTime : PSYSTEMTIME) : BOOL;
<* END *>  (*!*)
PROCEDURE GetLocalTime  (VAR SystemTime : SYSTEMTIME);
<* IF BACKEND # "C" THEN *>
PROCEDURE SetLocalTime  (SystemTime : SYSTEMTIME) : BOOL;
<* ELSE *>
PROCEDURE SetLocalTime  (SystemTime : PSYSTEMTIME) : BOOL;
<* END *>  (*!*)
PROCEDURE GetSystemInfo (VAR SystemInfo : SYSTEM_INFO);

TYPE TIME_ZONE_INFORMATION = RECORD
                                    Bias         : LONG;
                                    StandardName : ARRAY [0..31] OF WCHAR;
                                    StandardDate : SYSTEMTIME;
                                    StandardBias : LONG;
                                    DaylightName : ARRAY [0..31] OF WCHAR;
                                    DaylightDate : SYSTEMTIME;
                                    DaylightBias : LONG;
                             END;
    PTIME_ZONE_INFORMATION = POINTER TO TIME_ZONE_INFORMATION;

<* IF BACKEND # "C" THEN *>
PROCEDURE SystemTimeToTzSpecificLocalTime (
                        TimeZoneInformation : PTIME_ZONE_INFORMATION; (* IN NIL *)
                        UniversalTime : SYSTEMTIME; (*!*)
                        VAR LocalTime : SYSTEMTIME) : BOOL;
<* ELSE *>
PROCEDURE SystemTimeToTzSpecificLocalTime (
                        TimeZoneInformation : PTIME_ZONE_INFORMATION; (* IN NIL *)
                        UniversalTime : PSYSTEMTIME; (*!*)
                        VAR LocalTime : SYSTEMTIME) : BOOL;
<* END *>

PROCEDURE GetTimeZoneInformation
           (VAR TimeZoneInformation : TIME_ZONE_INFORMATION) : DWORD;

<* IF BACKEND # "C" THEN *>
PROCEDURE SetTimeZoneInformation
           (TimeZoneInformation : TIME_ZONE_INFORMATION) : BOOL;
<* ELSE *>
PROCEDURE SetTimeZoneInformation
           (TimeZoneInformation : PTIME_ZONE_INFORMATION) : BOOL;
<* END *>  (*!*)

(*
** Routines to convert back and forth between system time and file time
*)

<* IF BACKEND # "C" THEN *>
PROCEDURE SystemTimeToFileTime (SystemTime  : SYSTEMTIME; (*!*)
                                VAR FileTim : FILETIME) : BOOL;
<* ELSE *>
PROCEDURE SystemTimeToFileTime (SystemTime  : PSYSTEMTIME; (*!*)
                                VAR FileTim : FILETIME) : BOOL;
<* END *>

<* IF BACKEND # "C" THEN *>
PROCEDURE FileTimeToLocalFileTime (FileTime          : FILETIME; (*!*)
                                   VAR LocalFileTime : FILETIME) : BOOL;
<* ELSE *>
PROCEDURE FileTimeToLocalFileTime (FileTime          : PFILETIME; (*!*)
                                   VAR LocalFileTime : FILETIME) : BOOL;
<* END *>

<* IF BACKEND # "C" THEN *>
PROCEDURE LocalFileTimeToFileTime (LocalFileTime  : FILETIME; (*!*)
                                   VAR lpFileTime : FILETIME) : BOOL;
<* ELSE *>
PROCEDURE LocalFileTimeToFileTime (LocalFileTime  : PFILETIME; (*!*)
                                   VAR lpFileTime : FILETIME) : BOOL;
<* END *>

<* IF BACKEND # "C" THEN *>
PROCEDURE FileTimeToSystemTime (FileTime       : FILETIME; (*!*)
                                VAR SystemTime : SYSTEMTIME) : BOOL;
<* ELSE *>
PROCEDURE FileTimeToSystemTime (FileTime       : PFILETIME; (*!*)
                                VAR SystemTime : SYSTEMTIME) : BOOL;
<* END *>

<* IF BACKEND # "C" THEN *>
PROCEDURE CompareFileTime (FileTime1, FileTime2 : FILETIME) : LONG;
<* ELSE *>
PROCEDURE CompareFileTime (FileTime1, FileTime2 : PFILETIME) : LONG;
<* END *> (*!*)

<* IF BACKEND # "C" THEN *>
PROCEDURE FileTimeToDosDateTime (FileTime    : FILETIME; (*!*)
                                 VAR FatDate : WORD;
                                 VAR FatTime : WORD) : BOOL;
<* ELSE *>
PROCEDURE FileTimeToDosDateTime (FileTime    : PFILETIME; (*!*)
                                 VAR FatDate : WORD;
                                 VAR FatTime : WORD) : BOOL;
<* END *>

PROCEDURE DosDateTimeToFileTime (wFatDate     : WORD;
                                 wFatTime     : WORD;
                                 VAR FileTime : FILETIME) : BOOL;

PROCEDURE GetTickCount () : DWORD;
CONST GetCurrentTime = GetTickCount;

PROCEDURE SetSystemTimeAdjustment (dwTimeAdjustment        : DWORD;
                                   bTimeAdjustmentDisabled : BOOL) : BOOL;

PROCEDURE GetSystemTimeAdjustment (VAR TimeAdjustment         : DWORD;
                                   VAR TimeIncrement          : DWORD;
                                   VAR TimeAdjustmentDisabled : BOOL) : BOOL;

TYPE FORMAT_MESSAGE_SET = DWORD;
(* was not converted into bitset because small integral constants
   can be used in the low-order byte; so use arithmetic + when combining
   this all together and be careful not to use same flag twice *)

CONST FORMAT_MESSAGE_ALLOCATE_BUFFER = FORMAT_MESSAGE_SET (00000100h);
      FORMAT_MESSAGE_IGNORE_INSERTS  = FORMAT_MESSAGE_SET (00000200h);
      FORMAT_MESSAGE_FROM_STRING     = FORMAT_MESSAGE_SET (00000400h);
      FORMAT_MESSAGE_FROM_HMODULE    = FORMAT_MESSAGE_SET (00000800h);
      FORMAT_MESSAGE_FROM_SYSTEM     = FORMAT_MESSAGE_SET (00001000h);
      FORMAT_MESSAGE_ARGUMENT_ARRAY  = FORMAT_MESSAGE_SET (00002000h);
      FORMAT_MESSAGE_MAX_WIDTH_MASK  = FORMAT_MESSAGE_SET (000000FFh);

PROCEDURE FormatMessageA (dwFlags      : FORMAT_MESSAGE_SET;
                          lpSource     : LPCVOID;
                          dwMessageId  : DWORD;
                          dwLanguageId : DWORD;
                          lpBuffer     : PSTR;
                          nSize        : DWORD;
                          Arguments    : SYSTEM.ADDRESS) : DWORD;

PROCEDURE FormatMessageW (dwFlags      : FORMAT_MESSAGE_SET;
                          lpSource     : LPCVOID;
                          dwMessageId  : DWORD;
                          dwLanguageId : DWORD;
                          lpBuffer     : PWSTR;
                          nSize        : DWORD;
                          Arguments    : SYSTEM.ADDRESS) : DWORD;

<* IF DEFINED (UNICODE) THEN *>
      CONST FormatMessage = FormatMessageW;
<* ELSE *>
      CONST FormatMessage = FormatMessageA;
<* END *>

PROCEDURE CreatePipe (VAR hReadPipe    : HANDLE;
                      VAR hWritePipe   : HANDLE;
                      lpPipeAttributes : PSECURITY_ATTRIBUTES; (* IN NIL *)
                      nSize            : DWORD) : BOOL;

PROCEDURE ConnectNamedPipe (hNamedPipe           : HANDLE;
                            VAR [NIL] Overlapped : OVERLAPPED) : BOOL;

PROCEDURE DisconnectNamedPipe (hNamedPipe : HANDLE) : BOOL;

PROCEDURE SetNamedPipeHandleState (hNamedPipe                   : HANDLE;
                                   VAR [NIL] Mode               : PIPE_MODE_SET;
                                   VAR [NIL] MaxCollectionCount : DWORD;
                                   VAR [NIL] CollectDataTimeout : DWORD)
                                                                         : BOOL;

PROCEDURE GetNamedPipeInfo (hNamedPipe                : HANDLE;
                            VAR [NIL] Flags           : PIPE_MODE_SET;
                            VAR [NIL] lpOutBufferSize : DWORD;
                            VAR [NIL] lpInBufferSize  : DWORD;
                            VAR [NIL] lpMaxInstances  : DWORD) : BOOL;

PROCEDURE PeekNamedPipe (hNamedPipe                     : HANDLE;
                         lpBuffer                       : PVOID;
                         nBufferSize                    : DWORD;
                         VAR [NIL] BytesRead            : DWORD;
                         VAR [NIL] TotalBytesAvail      : DWORD;
                         VAR [NIL] BytesLeftThisMessage : DWORD) : BOOL;

PROCEDURE TransactNamedPipe (hNamedPipe           : HANDLE;
                             lpInBuffer           : PVOID;
                             nInBufferSize        : DWORD;
                             lpOutBuffer          : PVOID;
                             nOutBufferSize       : DWORD;
                             VAR lpBytesRead      : DWORD;
                             VAR [NIL] Overlapped : OVERLAPPED) : BOOL;

PROCEDURE CreateMailslotA (Name                 : ARRAY OF CHAR;
                           nMaxMessageSize      : DWORD;
                           lReadTimeout         : DWORD;
                           lpSecurityAttributes : PSECURITY_ATTRIBUTES) (*!*)
                                                                       : HANDLE;

PROCEDURE CreateMailslotW (Name                 : ARRAY OF WCHAR;
                           nMaxMessageSize      : DWORD;
                           lReadTimeout         : DWORD;
                           lpSecurityAttributes : PSECURITY_ATTRIBUTES) (*!*)
                                                                       : HANDLE;

<* IF DEFINED (UNICODE) THEN *>
      CONST CreateMailslot = CreateMailslotW;
<* ELSE *>
      CONST CreateMailslot = CreateMailslotA;
<* END *>

PROCEDURE GetMailslotInfo (hMailslot                : HANDLE;
                           VAR [NIL] MaxMessageSize : DWORD;
                           VAR [NIL] NextSize       : DWORD;
                           VAR [NIL] MessageCount   : DWORD;
                           VAR [NIL] ReadTimeout    : DWORD) : BOOL;

PROCEDURE SetMailslotInfo (hMailslot    : HANDLE;
                           lReadTimeout : DWORD) : BOOL;

PROCEDURE MapViewOfFile (hFileMappingObject   : HANDLE;
                         dwDesiredAccess      : ACCESS_MASK;
                         dwFileOffsetHigh     : DWORD;
                         dwFileOffsetLow      : DWORD;
                         dwNumberOfBytesToMap : DWORD) : PVOID;

PROCEDURE FlushViewOfFile (lpBaseAddress          : LPCVOID;
                           dwNumberOfBytesToFlush : DWORD) : BOOL;

PROCEDURE UnmapViewOfFile (lpBaseAddress : LPCVOID) : BOOL;

(*
** _l Compat Functions
*)

(* arguments were not converted to ARRAY OF CHAR for convinience
   of operations with parts of arrays *)

PROCEDURE lstrcmpA (lpString1, lpString2 : PCSTR ) : INTEGER;
PROCEDURE lstrcmpW (lpString1, lpString2 : PCWSTR) : INTEGER;

<* IF DEFINED (UNICODE) THEN *>
      CONST lstrcmp = lstrcmpW;
<* ELSE *>
      CONST lstrcmp = lstrcmpA;
<* END *>

PROCEDURE lstrcmpiA (String1, String2 : PCSTR ) : INTEGER;
PROCEDURE lstrcmpiW (String1, String2 : PCWSTR) : INTEGER;

<* IF DEFINED (UNICODE) THEN *>
      CONST lstrcmpi = lstrcmpiW;
<* ELSE *>
      CONST lstrcmpi = lstrcmpiA;
<* END *>

PROCEDURE lstrcpynA (String1 : PSTR;  String2 : PCSTR;  MaxLength : INTEGER) : PSTR;
PROCEDURE lstrcpynW (String1 : PWSTR; String2 : PCWSTR; MaxLength : INTEGER) : PWSTR;

<* IF DEFINED (UNICODE) THEN *>
      CONST lstrcpyn = lstrcpynW;
<* ELSE *>
      CONST lstrcpyn = lstrcpynA;
<* END *>

PROCEDURE lstrcpyA (lpString1 : PSTR;  lpString2 : PCSTR)  : PSTR;
PROCEDURE lstrcpyW (lpString1 : PWSTR; lpString2 : PCWSTR) : PWSTR;

<* IF DEFINED (UNICODE) THEN *>
      CONST lstrcpy = lstrcpyW;
<* ELSE *>
      CONST lstrcpy = lstrcpyA;
<* END *>

PROCEDURE lstrcatA (lpString1 : PSTR;  lpString2 : PCSTR)  : PSTR;
PROCEDURE lstrcatW (lpString1 : PWSTR; lpString2 : PCWSTR) : PWSTR;

<* IF DEFINED (UNICODE) THEN *>
      CONST lstrcat = lstrcatW;
<* ELSE *>
      CONST lstrcat = lstrcatA;
<* END *>

PROCEDURE lstrlenA (lpString : PCSTR ) : INTEGER;
PROCEDURE lstrlenW (lpString : PCWSTR) : INTEGER;

<* IF DEFINED (UNICODE) THEN *>
      CONST lstrlen = lstrlenW;
<* ELSE *>
      CONST lstrlen = lstrlenA;
<* END *>

PROCEDURE OpenFile (FileName             : ARRAY OF CHAR;
                    VAR [NIL] ReOpenBuff : OFSTRUCT;
                    uStyle               : OF_FLAGS) : HFILE;

PROCEDURE _lopen  (PathName : ARRAY OF CHAR; iReadWrite : OF_FLAGS) : HFILE;
PROCEDURE _lcreat (PathName : ARRAY OF CHAR; iAttribute : OF_FLAGS) : HFILE;
PROCEDURE _lread  (hFile : HFILE; lpBuffer : PVOID; uBytes : UINT) : UINT;
PROCEDURE _lwrite (hFile : HFILE; lpBuffer : PCSTR; uBytes : UINT) : UINT;
PROCEDURE _hread  (hFile : HFILE; lpBuffer : PVOID; lBytes : LONG) : LONG;
PROCEDURE _hwrite (hFile : HFILE; lpBuffer : LPCVOID; lBytes : LONG) : LONG;
PROCEDURE _lclose (hFile : HFILE) : HFILE;
PROCEDURE _llseek (hFile : HFILE; lOffset : LONG; iOrigin : MOVE_TYPE) : LONG;

PROCEDURE IsTextUnicode (lpBuffer : LPCVOID;
                         cb       : INTEGER;
                         lpi      : IS_TEXT_UNICODE_SET) : BOOL;

PROCEDURE TlsAlloc () : DWORD;

CONST TLS_OUT_OF_INDEXES = 0FFFFFFFFh;

PROCEDURE TlsGetValue (dwTlsIndex : DWORD) : PVOID;
PROCEDURE TlsSetValue (dwTlsIndex : DWORD; lpTlsValue : PVOID) : BOOL;
PROCEDURE TlsFree (dwTlsIndex : DWORD) : BOOL;

TYPE POVERLAPPED_COMPLETION_ROUTINE = PROCEDURE (
                (* dwErrorCode : *)               DWORD,
                (* dwNumberOfBytesTransfered : *) DWORD,
                VAR (* Overlapped : *)            OVERLAPPED);

PROCEDURE SleepEx (dwMilliseconds : DWORD; bAlertable : BOOL) : DWORD;

PROCEDURE WaitForSingleObjectEx (hHandle        : HANDLE;
                                 dwMilliseconds : DWORD;
                                 bAlertable     : BOOL) : DWORD;

PROCEDURE WaitForMultipleObjectsEx (nCount         : DWORD;
                                    Handles        : ARRAY OF HANDLE;
                                    bWaitAll       : BOOL;
                                    dwMilliseconds : DWORD;
                                    bAlertable     : BOOL) : DWORD;

PROCEDURE SignalObjectAndWait (hObjectToSignal : HANDLE;
                               hObjectToWaitOn : HANDLE;
                               dwMilliseconds  : DWORD;
                               bAlertable      : BOOL) : DWORD;

PROCEDURE ReadFileEx (hFile                : HANDLE;
                      lpBuffer             : PVOID;
                      nNumberOfBytesToRead : DWORD;
                      VAR Overlapped       : OVERLAPPED;
                      lpCompletionRoutine  : POVERLAPPED_COMPLETION_ROUTINE
                                                                      ) : BOOL;
PROCEDURE WriteFileEx (hFile                 : HANDLE;
                       lpBuffer              : LPCVOID;
                       nNumberOfBytesToWrite : DWORD;
                       VAR Overlapped        : OVERLAPPED;
                       lpCompletionRoutine   : POVERLAPPED_COMPLETION_ROUTINE
                                                                     ) : BOOL;
PROCEDURE BackupRead (hFile                   : HANDLE;
                      lpBuffer                : PBYTE;
                      nNumberOfBytesToRead    : DWORD;
                      VAR lpNumberOfBytesRead : DWORD;
                      bAbort                  : BOOL;
                      bProcessSecurity        : BOOL;
                      VAR lpContext           : PVOID) : BOOL;

PROCEDURE BackupSeek (hFile                : HANDLE;
                      dwLowBytesToSeek     : DWORD;
                      dwHighBytesToSeek    : DWORD;
                      VAR dwLowByteSeeked  : DWORD;
                      VAR dwHighByteSeeked : DWORD;
                      VAR lpContext        : PVOID) : BOOL;

PROCEDURE BackupWrite (hFile                    : HANDLE;
                       lpBuffer                 : PBYTE;
                       nNumberOfBytesToWrite    : DWORD;
                       VAR NumberOfBytesWritten : DWORD;
                       bAbort                   : BOOL;
                       bProcessSecurity         : BOOL;
                       VAR lpContext            : PVOID) : BOOL;

(*
**  Stream Ids
*)

TYPE STREAM_ID = (BACKUP_INVALID,        (* 00000000 *)
                  BACKUP_DATA,           (* 00000001 *)
                  BACKUP_EA_DATA,        (* 00000002 *)
                  BACKUP_SECURITY_DATA,  (* 00000003 *)
                  BACKUP_ALTERNATE_DATA, (* 00000004 *)
                  BACKUP_LINK,           (* 00000005 *)
                  BACKUP_PROPERTY_DATA); (* 00000006 *)

(*
**  Stream Attributes
*)

TYPE STREAM_ATTR_ENUM = (STREAM__MODIFIED_WHEN_READ,   (* 0 *)
                         STREAM__CONTAINS_SECURITY,    (* 1 *)
                         STREAM__CONTAINS_PROPERTIES); (* 2 *)

     STREAM_ATTR_SET = SET OF STREAM_ATTR_ENUM;

CONST STREAM_NORMAL_ATTRIBUTE    = STREAM_ATTR_SET {};                            (* 0x00000000 *)
      STREAM_MODIFIED_WHEN_READ  = STREAM_ATTR_SET {STREAM__MODIFIED_WHEN_READ};  (* 0x00000001 *)
      STREAM_CONTAINS_SECURITY   = STREAM_ATTR_SET {STREAM__CONTAINS_SECURITY};   (* 0x00000002 *)
      STREAM_CONTAINS_PROPERTIES = STREAM_ATTR_SET {STREAM__CONTAINS_PROPERTIES}; (* 0x00000004 *)

(*
**  Stream id structure
*)

TYPE WIN32_STREAM_ID = RECORD
                              dwStreamId         : STREAM_ID;
                              dwStreamAttributes : STREAM_ATTR_SET;
                              Size               : LARGE_INTEGER;
                              dwStreamNameSize   : DWORD;
                              cStreamName        : ARRAY [0..0] OF WCHAR;
                       END;
    PWIN32_STREAM_ID = POINTER TO WIN32_STREAM_ID;

(*
** Dual Mode API below this line. Dual Mode Structures also included.
*)

TYPE STARTF_ENUM = (STARTF__USESHOWWINDOW,    (* 0 *)
                    STARTF__USESIZE,          (* 1 *)
                    STARTF__USEPOSITION,      (* 2 *)
                    STARTF__USECOUNTCHARS,    (* 3 *)
                    STARTF__USEFILLATTRIBUTE, (* 4 *)
                    STARTF__RUNFULLSCREEN,    (* 5 *) (* ignored for non-x86 platforms *)
                    STARTF__FORCEONFEEDBACK,  (* 6 *)
                    STARTF__FORCEOFFFEEDBACK, (* 7 *)
                    STARTF__USESTDHANDLES,    (* 8 *)
                    STARTF__USEHOTKEY);       (* 9 *)

     STARTF_SET = SET OF STARTF_ENUM;

CONST STARTF_USESHOWWINDOW    = STARTF_SET {STARTF__USESHOWWINDOW    }; (* 0x00000001 *)
      STARTF_USESIZE          = STARTF_SET {STARTF__USESIZE          }; (* 0x00000002 *)
      STARTF_USEPOSITION      = STARTF_SET {STARTF__USEPOSITION      }; (* 0x00000004 *)
      STARTF_USECOUNTCHARS    = STARTF_SET {STARTF__USECOUNTCHARS    }; (* 0x00000008 *)
      STARTF_USEFILLATTRIBUTE = STARTF_SET {STARTF__USEFILLATTRIBUTE }; (* 0x00000010 *)
      STARTF_RUNFULLSCREEN    = STARTF_SET {STARTF__RUNFULLSCREEN    }; (* 0x00000020 *)
      STARTF_FORCEONFEEDBACK  = STARTF_SET {STARTF__FORCEONFEEDBACK  }; (* 0x00000040 *)
      STARTF_FORCEOFFFEEDBACK = STARTF_SET {STARTF__FORCEOFFFEEDBACK }; (* 0x00000080 *)
      STARTF_USESTDHANDLES    = STARTF_SET {STARTF__USESTDHANDLES    }; (* 0x00000100 *)
      STARTF_USEHOTKEY        = STARTF_SET {STARTF__USEHOTKEY        }; (* 0x00000200 *)

TYPE STARTUPINFOA = RECORD
                           cb              : DWORD;
                           lpReserved      : PSTR;
                           lpDesktop       : PSTR;
                           lpTitle         : PSTR;
                           dwX             : DWORD;
                           dwY             : DWORD;
                           dwXSize         : DWORD;
                           dwYSize         : DWORD;
                           dwXCountChars   : DWORD;
                           dwYCountChars   : DWORD;
                           dwFillAttribute : DWORD;  (* actually CHAR_ATTRIBUTES_SET from WinCon.def *)
                           dwFlags         : STARTF_SET;
                           wShowWindow     : WORD;   (* actually SW_ENUM *)
                           cbReserved2     : WORD;
                           lpReserved2     : PBYTE;
                           hStdInput       : HANDLE;
                           hStdOutput      : HANDLE;
                           hStdError       : HANDLE;
                    END;
    PSTARTUPINFOA = POINTER TO STARTUPINFOA;

TYPE STARTUPINFOW = RECORD
                           cb              : DWORD;
                           lpReserved      : PWSTR;
                           lpDesktop       : PWSTR;
                           lpTitle         : PWSTR;
                           dwX             : DWORD;
                           dwY             : DWORD;
                           dwXSize         : DWORD;
                           dwYSize         : DWORD;
                           dwXCountChars   : DWORD;
                           dwYCountChars   : DWORD;
                           dwFillAttribute : DWORD;  (* actually CHAR_ATTRIBUTES_SET from WinCon.def *)
                           dwFlags         : STARTF_SET;
                           wShowWindow     : WORD;   (* actually SW_ENUM *)
                           cbReserved2     : WORD;
                           lpReserved2     : PBYTE;
                           hStdInput       : HANDLE;
                           hStdOutput      : HANDLE;
                           hStdError       : HANDLE;
                    END;
    PSTARTUPINFOW = POINTER TO STARTUPINFOW;

<* IF DEFINED (UNICODE) THEN *>
       TYPE  STARTUPINFO =  STARTUPINFOW;
            PSTARTUPINFO = PSTARTUPINFOW;
<* ELSE *>
       TYPE  STARTUPINFO  =  STARTUPINFOA;
            PSTARTUPINFO  = PSTARTUPINFOA;
<* END *>

CONST SHUTDOWN_NORETRY = 1;

TYPE WIN32_FIND_DATAA = RECORD
                               dwFileAttributes   : FILE_ATTRIBUTE_SET;
                               ftCreationTime     : FILETIME;
                               ftLastAccessTime   : FILETIME;
                               ftLastWriteTime    : FILETIME;
                               nFileSizeHigh      : DWORD;
                               nFileSizeLow       : DWORD;
                               dwReserved0        : DWORD;
                               dwReserved1        : DWORD;
                               cFileName          : ARRAY [0..MAX_PATH-1] OF CHAR;
                               cAlternateFileName : ARRAY [0..13] OF CHAR;
                        END;
    PWIN32_FIND_DATAA = POINTER TO WIN32_FIND_DATA;

     WIN32_FIND_DATAW = RECORD
                               dwFileAttributes   : FILE_ATTRIBUTE_SET;
                               ftCreationTime     : FILETIME;
                               ftLastAccessTime   : FILETIME;
                               ftLastWriteTime    : FILETIME;
                               nFileSizeHigh      : DWORD;
                               nFileSizeLow       : DWORD;
                               dwReserved0        : DWORD;
                               dwReserved1        : DWORD;
                               cFileName          : ARRAY [0..MAX_PATH-1] OF WCHAR;
                               cAlternateFileName : ARRAY [0..13] OF WCHAR;
                        END;
    PWIN32_FIND_DATAW = POINTER TO WIN32_FIND_DATAW;

<* IF DEFINED (UNICODE) THEN *>
       TYPE  WIN32_FIND_DATA =  WIN32_FIND_DATAW;
            PWIN32_FIND_DATA = PWIN32_FIND_DATAW;
<* ELSE *>
       TYPE  WIN32_FIND_DATA =  WIN32_FIND_DATAA;
            PWIN32_FIND_DATA = PWIN32_FIND_DATAA;
<* END *>

TYPE WIN32_FILE_ATTRIBUTE_DATA =
     RECORD
          dwFileAttributes : FILE_ATTRIBUTE_SET;
          ftCreationTime : FILETIME;
          ftLastAccessTime : FILETIME;
          ftLastWriteTime : FILETIME;
          nFileSizeHigh : DWORD;
          nFileSizeLow : DWORD;
     END;
     PWIN32_FILE_ATTRIBUTE_DATA = POINTER TO WIN32_FILE_ATTRIBUTE_DATA;

PROCEDURE CreateMutexA (lpMutexAttributes : PSECURITY_ATTRIBUTES;
                        bInitialOwner     : BOOL;
                        lpName            : PCSTR)                    (* IN NIL *)
                                                   : HANDLE;

PROCEDURE CreateMutexW (lpMutexAttributes : PSECURITY_ATTRIBUTES;
                        bInitialOwner     : BOOL;
                        lpName            : PCWSTR)                   (* IN NIL *)
                                                   : HANDLE;

<* IF DEFINED (UNICODE) THEN *>
      CONST CreateMutex = CreateMutexW;
<* ELSE *>
      CONST CreateMutex = CreateMutexA;
<* END *>

PROCEDURE OpenMutexA (DesiredAccess  : ACCESS_MASK;
                      bInheritHandle : BOOL;
                      Name           : ARRAY OF CHAR) : HANDLE;

PROCEDURE OpenMutexW (DesiredAccess  : ACCESS_MASK;
                      bInheritHandle : BOOL;
                      Name           : ARRAY OF WCHAR) : HANDLE;

<* IF DEFINED (UNICODE) THEN *>
      CONST OpenMutex = OpenMutexW;
<* ELSE *>
      CONST OpenMutex = OpenMutexA;
<* END *>

PROCEDURE CreateEventA (lpEventAttributes : PSECURITY_ATTRIBUTES;
                        bManualReset      : BOOL;
                        bInitialState     : BOOL;
                        lpName            : PCSTR)             (* IN NIL *)
                                                   : HANDLE;

PROCEDURE CreateEventW (lpEventAttributes : PSECURITY_ATTRIBUTES;
                        bManualReset      : BOOL;
                        bInitialState     : BOOL;
                        lpName            : PCWSTR)            (* IN NIL *)
                                                    : HANDLE;

<* IF DEFINED (UNICODE) THEN *>
      CONST CreateEvent = CreateEventW;
<* ELSE *>
      CONST CreateEvent = CreateEventA;
<* END *>

PROCEDURE OpenEventA (dwDesiredAccess : ACCESS_MASK;
                      bInheritHandle  : BOOL;
                      Name            : ARRAY OF CHAR) : HANDLE;

PROCEDURE OpenEventW (dwDesiredAccess : ACCESS_MASK;
                      bInheritHandle  : BOOL;
                      Name            : ARRAY OF WCHAR) : HANDLE;

<* IF DEFINED (UNICODE) THEN *>
      CONST OpenEvent = OpenEventW;
<* ELSE *>
      CONST OpenEvent = OpenEventA;
<* END *>

PROCEDURE CreateSemaphoreA (lpSemaphoreAttributes : PSECURITY_ATTRIBUTES;
                           lInitialCount          : LONG;
                           lMaximumCount          : LONG;
                           lpName                 : PCSTR)           (* IN NIL *)
                                                           : HANDLE;

PROCEDURE CreateSemaphoreW (lpSemaphoreAttributes : PSECURITY_ATTRIBUTES;
                            lInitialCount         : LONG;
                            lMaximumCount         : LONG;
                            lpName                : PCWSTR)           (* IN NIL *)
                                                            : HANDLE;

<* IF DEFINED (UNICODE) THEN *>
      CONST CreateSemaphore = CreateSemaphoreW;
<* ELSE *>
      CONST CreateSemaphore = CreateSemaphoreA;
<* END *>

PROCEDURE OpenSemaphoreA (dwDesiredAccess : ACCESS_MASK;
                          bInheritHandle  : BOOL;
                          Name            : ARRAY OF CHAR) : HANDLE;

PROCEDURE OpenSemaphoreW (dwDesiredAccess : ACCESS_MASK;
                          bInheritHandle  : BOOL;
                          Name            : ARRAY OF WCHAR) : HANDLE;

<* IF DEFINED (UNICODE) THEN *>
      CONST OpenSemaphore = OpenSemaphoreW;
<* ELSE *>
      CONST OpenSemaphore = OpenSemaphoreA;
<* END *>

TYPE PTIMERAPCROUTINE = PROCEDURE ((* lpArgToCompletionRoutine : *) PVOID,
                                   (* dwTimerLowValue          : *) DWORD,
                                   (* dwTimerHighValue         : *) DWORD);

PROCEDURE CreateWaitableTimerA (lpTimerAttributes : PSECURITY_ATTRIBUTES;
                                bManualReset      : BOOL;
                                lpTimerName       : PCSTR)           (* IN NIL *)
                                                           : HANDLE;

PROCEDURE CreateWaitableTimerW (lpTimerAttributes : PSECURITY_ATTRIBUTES;
                                bManualReset      : BOOL;
                                lpTimerName       : PCWSTR)           (* IN NIL *)
                                                           : HANDLE;
<* IF DEFINED (UNICODE) THEN *>
      CONST CreateWaitableTimer = CreateWaitableTimerW;
<* ELSE *>
      CONST CreateWaitableTimer = CreateWaitableTimerA;
<* END *>

PROCEDURE OpenWaitableTimerA (dwDesiredAccess : DWORD;
                              bInheritHandle  : BOOL;
                              TimerName       : ARRAY OF CHAR) : HANDLE;

PROCEDURE OpenWaitableTimerW (dwDesiredAccess : DWORD;
                              bInheritHandle  : BOOL;
                              TimerName       : ARRAY OF WCHAR) : HANDLE;

<* IF DEFINED (UNICODE) THEN *>
      CONST OpenWaitableTimer = OpenWaitableTimerW;
<* ELSE *>
      CONST OpenWaitableTimer = OpenWaitableTimerA;
<* END *>

<* IF BACKEND # "C" THEN *>
PROCEDURE SetWaitableTimer (hTimer                   : HANDLE;
                            DueTime                  : LARGE_INTEGER; (* IN *)
                            lPeriod                  : LONG;
                            pfnCompletionRoutine     : PTIMERAPCROUTINE;
                            lpArgToCompletionRoutine : PVOID;
                            fResume                  : BOOL) : BOOL;
<* ELSE *>
PROCEDURE SetWaitableTimer (hTimer                   : HANDLE;
                            DueTime                  : PLARGE_INTEGER; (* IN *)
                            lPeriod                  : LONG;
                            pfnCompletionRoutine     : PTIMERAPCROUTINE;
                            lpArgToCompletionRoutine : PVOID;
                            fResume                  : BOOL) : BOOL;
<* END *>

PROCEDURE CancelWaitableTimer (hTimer : HANDLE) : BOOL;

PROCEDURE CreateFileMappingA (hFile                   : HANDLE;
                              lpFileMappingAttributes : PSECURITY_ATTRIBUTES;
                              flProtect               : PROTECT_SET;
                              dwMaximumSizeHigh       : DWORD;
                              dwMaximumSizeLow        : DWORD;
                              lpName                  : PCSTR)           (* IN NIL *)
                                                               : HANDLE;

PROCEDURE CreateFileMappingW (hFile                   : HANDLE;
                              lpFileMappingAttributes : PSECURITY_ATTRIBUTES;
                              flProtect               : PROTECT_SET;
                              dwMaximumSizeHigh       : DWORD;
                              dwMaximumSizeLow        : DWORD;
                              lpName                  : PCWSTR)           (* IN NIL *)
                                                                : HANDLE ;
<* IF DEFINED (UNICODE) THEN *>
      CONST CreateFileMapping = CreateFileMappingW;
<* ELSE *>
      CONST CreateFileMapping = CreateFileMappingA;
<* END *>

PROCEDURE OpenFileMappingA (dwDesiredAccess : ACCESS_MASK;
                            bInheritHandle  : BOOL;
                            Name            : ARRAY OF CHAR) : HANDLE;

PROCEDURE OpenFileMappingW (dwDesiredAccess : ACCESS_MASK;
                            bInheritHandle  : BOOL;
                            Name            : ARRAY OF WCHAR) : HANDLE;

<* IF DEFINED (UNICODE) THEN *>
      CONST OpenFileMapping = OpenFileMappingW;
<* ELSE *>
      CONST OpenFileMapping = OpenFileMappingA;
<* END *>

PROCEDURE GetLogicalDriveStringsA (nBufferLength : DWORD;
                                   VAR Buffer    : ARRAY OF CHAR) : DWORD;

PROCEDURE GetLogicalDriveStringsW (nBufferLength : DWORD;
                                   VAR Buffer    : ARRAY OF WCHAR) : DWORD;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetLogicalDriveStrings = GetLogicalDriveStringsW;
<* ELSE *>
      CONST GetLogicalDriveStrings = GetLogicalDriveStringsA;
<* END *>

PROCEDURE LoadLibraryA (LibFileName : ARRAY OF CHAR)  : HMODULE;
PROCEDURE LoadLibraryW (LibFileName : ARRAY OF WCHAR) : HMODULE;

<* IF DEFINED (UNICODE) THEN *>
      CONST LoadLibrary = LoadLibraryW;
<* ELSE *>
      CONST LoadLibrary = LoadLibraryA;
<* END *>

TYPE LOAD_LIB_ENUM  = (LLE__0, LLE__1, LLE__2, LLE__3);
     LOAD_LIB_FLAGS = SET OF LOAD_LIB_ENUM;

CONST DONT_RESOLVE_DLL_REFERENCES     = LOAD_LIB_FLAGS {LLE__0}; (* 0x00000001 *)
      LOAD_LIBRARY_AS_DATAFILE        = LOAD_LIB_FLAGS {LLE__1}; (* 0x00000002 *)
      LOAD_WITH_ALTERED_SEARCH_PATH   = LOAD_LIB_FLAGS {LLE__3}; (* 0x00000008 *)

PROCEDURE LoadLibraryExA (LibFileName : ARRAY OF CHAR;
                          hFile       : HANDLE;
                          dwFlags     : LOAD_LIB_FLAGS) : HMODULE;

PROCEDURE LoadLibraryExW (LibFileName : ARRAY OF WCHAR;
                          hFile       : HANDLE;
                          dwFlags     : LOAD_LIB_FLAGS) : HMODULE;

<* IF DEFINED (UNICODE) THEN *>
      CONST LoadLibraryEx = LoadLibraryExW;
<* ELSE *>
      CONST LoadLibraryEx = LoadLibraryExA;
<* END *>

PROCEDURE GetModuleFileNameA (hModule      : HMODULE;
                              VAR Filename : ARRAY OF CHAR;
                              nSize        : DWORD) : DWORD;

PROCEDURE GetModuleFileNameW (hModule      : HMODULE;
                              VAR Filename : ARRAY OF WCHAR;
                              nSize        : DWORD) : DWORD;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetModuleFileName = GetModuleFileNameW;
<* ELSE *>
      CONST GetModuleFileName = GetModuleFileNameA;
<* END *>

PROCEDURE GetModuleHandleA (ModuleName : PCSTR)  : HMODULE; (* NIL *)
PROCEDURE GetModuleHandleW (ModuleName : PCWSTR) : HMODULE; (* NIL *)

<* IF DEFINED (UNICODE) THEN *>
      CONST GetModuleHandle = GetModuleHandleW;
<* ELSE *>
      CONST GetModuleHandle = GetModuleHandleA;
<* END *>

PROCEDURE CreateProcessA (lpApplicationName      : PCSTR; (* IN NIL *)
                          lpCommandLine          : PCSTR; (* IN NIL *)
                          lpProcessAttributes    : PSECURITY_ATTRIBUTES; (* IN NIL *)
                          lpThreadAttributes     : PSECURITY_ATTRIBUTES; (* IN NIL *)
                          bInheritHandles        : BOOL;
                          dwCreationFlags        : CREATE_SET;
                          lpEnvironment          : PVOID;
                          lpCurrentDirectory     : PCSTR; (* IN NIL *)
                          VAR StartupInfo        : STARTUPINFOA; (* IN *)
                          VAR ProcessInformation : PROCESS_INFORMATION) : BOOL;

PROCEDURE CreateProcessW (lpApplicationName      : PCWSTR; (* IN NIL *)
                          lpCommandLine          : PCWSTR; (* IN NIL *)
                          lpProcessAttributes    : PSECURITY_ATTRIBUTES; (* IN NIL *)
                          lpThreadAttributes     : PSECURITY_ATTRIBUTES; (* IN NIL *)
                          bInheritHandles        : BOOL;
                          dwCreationFlags        : CREATE_SET;
                          lpEnvironment          : PVOID;
                          lpCurrentDirectory     : PCWSTR; (* IN NIL *)
                          VAR StartupInfo        : STARTUPINFOW; (* IN *)
                          VAR ProcessInformation : PROCESS_INFORMATION) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST CreateProcess = CreateProcessW;
<* ELSE *>
      CONST CreateProcess = CreateProcessA;
<* END *>

PROCEDURE SetProcessShutdownParameters (dwLevel : DWORD;
                                        dwFlags : DWORD) : BOOL;

PROCEDURE GetProcessShutdownParameters (VAR Level : DWORD;
                                        VAR Flags : DWORD) : BOOL;

PROCEDURE GetProcessVersion (ProcessId : DWORD) : DWORD;
PROCEDURE FatalAppExitA (uAction : UINT; MessageText : ARRAY OF CHAR);
PROCEDURE FatalAppExitW (uAction : UINT; MessageText : ARRAY OF WCHAR);

<* IF DEFINED (UNICODE) THEN *>
      CONST FatalAppExit = FatalAppExitW;
<* ELSE *>
      CONST FatalAppExit = FatalAppExitA;
<* END *>

PROCEDURE GetStartupInfoA (VAR StartupInfo : STARTUPINFOA);
PROCEDURE GetStartupInfoW (VAR StartupInfo : STARTUPINFOW);

<* IF DEFINED (UNICODE) THEN *>
      CONST GetStartupInfo = GetStartupInfoW;
<* ELSE *>
      CONST GetStartupInfo = GetStartupInfoA;
<* END *>

PROCEDURE GetCommandLineA () : PSTR;
PROCEDURE GetCommandLineW () : PWSTR;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetCommandLine = GetCommandLineW;
<* ELSE *>
      CONST GetCommandLine = GetCommandLineA;
<* END *>

PROCEDURE GetEnvironmentVariableA (Name       : ARRAY OF CHAR;
                                   VAR Buffer : ARRAY OF CHAR;
                                   nSize      : DWORD)
                                                       : DWORD;

PROCEDURE GetEnvironmentVariableW (Name       : ARRAY OF WCHAR;
                                   VAR Buffer : ARRAY OF WCHAR;
                                   nSize      : DWORD)
                                                       : DWORD;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetEnvironmentVariable = GetEnvironmentVariableW;
<* ELSE *>
      CONST GetEnvironmentVariable = GetEnvironmentVariableA;
<* END *>

PROCEDURE SetEnvironmentVariableA (Name  : ARRAY OF CHAR;
                                   Value : ARRAY OF CHAR) : BOOL;

PROCEDURE SetEnvironmentVariableW (Name  : ARRAY OF WCHAR;
                                   Value : ARRAY OF WCHAR) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST SetEnvironmentVariable = SetEnvironmentVariableW;
<* ELSE *>
      CONST SetEnvironmentVariable = SetEnvironmentVariableA;
<* END *>

PROCEDURE ExpandEnvironmentStringsA (Src     : ARRAY OF CHAR;
                                     VAR Dst : ARRAY OF CHAR;
                                     nSize   : DWORD)
                                                      : DWORD;

PROCEDURE ExpandEnvironmentStringsW (Src     : ARRAY OF WCHAR;
                                     VAR Dst : ARRAY OF WCHAR;
                                     nSize   : DWORD)
                                                      : DWORD;

<* IF DEFINED (UNICODE) THEN *>
      CONST ExpandEnvironmentStrings = ExpandEnvironmentStringsW;
<* ELSE *>
      CONST ExpandEnvironmentStrings = ExpandEnvironmentStringsA;
<* END *>

PROCEDURE OutputDebugStringA (OutputString : ARRAY OF CHAR);
PROCEDURE OutputDebugStringW (OutputString : ARRAY OF WCHAR);

<* IF DEFINED (UNICODE) THEN *>
      CONST OutputDebugString = OutputDebugStringW;
<* ELSE *>
      CONST OutputDebugString = OutputDebugStringA;
<* END *>

PROCEDURE FindResourceA (hModule : HMODULE;
                         lpName  : RESOURCESTRA;
                         lpType  : RESOURCESTRA) : HRSRC;

PROCEDURE FindResourceW (hModule : HMODULE;
                         lpName  : RESOURCESTRW;
                         lpType  : RESOURCESTRW) : HRSRC;

<* IF DEFINED (UNICODE) THEN *>
      CONST FindResource = FindResourceW;
<* ELSE *>
      CONST FindResource = FindResourceA;
<* END *>

PROCEDURE FindResourceExA (hModule   : HMODULE;
                           lpType    : RESOURCESTRA;
                           lpName    : RESOURCESTRA;
                           wLanguage : WORD) : HRSRC;

PROCEDURE FindResourceExW (hModule   : HMODULE;
                           lpType    : RESOURCESTRW;
                           lpName    : RESOURCESTRW;
                           wLanguage : WORD) : HRSRC;

<* IF DEFINED (UNICODE) THEN *>
      CONST FindResourceEx = FindResourceExW;
<* ELSE *>
      CONST FindResourceEx = FindResourceExA;
<* END *>

TYPE ENUMRESTYPEPROCA = PROCEDURE ((* hModule : *) HMODULE,
                                   (* lpType  : *) RESOURCESTRA,
                                   (* lParam  : *) LONG) : BOOL;

TYPE ENUMRESTYPEPROCW = PROCEDURE ((* hModule : *) HMODULE,
                                   (* lpType  : *) RESOURCESTRW,
                                   (* lParam  : *) LONG) : BOOL;


TYPE ENUMRESNAMEPROCA = PROCEDURE ((* hModule : *) HMODULE,
                                   (* lpType  : *) RESOURCESTRA,
                                   (* lpName  : *) RESOURCESTRA,
                                   (* lParam  : *) LONG) : BOOL;

TYPE ENUMRESNAMEPROCW = PROCEDURE ((* hModule : *) HMODULE,
                                   (* lpType  : *) RESOURCESTRW,
                                   (* lpName  : *) RESOURCESTRW,
                                   (* lParam  : *) LONG) : BOOL;


TYPE ENUMRESLANGPROCA = PROCEDURE ((* hModule   : *) HMODULE,
                                   (* lpType    : *) RESOURCESTRA,
                                   (* lpName    : *) RESOURCESTRA,
                                   (* wLanguage : *) WORD,
                                   (* lParam    : *) LONG) : BOOL;

TYPE ENUMRESLANGPROCW = PROCEDURE ((* hModule   : *) HMODULE,
                                   (* lpType    : *) RESOURCESTRW,
                                   (* lpName    : *) RESOURCESTRW,
                                   (* wLanguage : *) WORD,
                                   (* lParam    : *) LONG) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      TYPE ENUMRESTYPEPROC = ENUMRESTYPEPROCW;
           ENUMRESNAMEPROC = ENUMRESNAMEPROCW;
           ENUMRESLANGPROC = ENUMRESLANGPROCW;
<* ELSE *>
      TYPE ENUMRESTYPEPROC = ENUMRESTYPEPROCA;
           ENUMRESNAMEPROC = ENUMRESNAMEPROCA;
           ENUMRESLANGPROC = ENUMRESLANGPROCA;
<* END *>

PROCEDURE EnumResourceTypesA (hModule   : HMODULE;
                             lpEnumFunc : ENUMRESTYPEPROCA;
                             lParam     : LONG) : BOOL;

PROCEDURE EnumResourceTypesW (hModule    : HMODULE;
                              lpEnumFunc : ENUMRESTYPEPROCW;
                              lParam     : LONG) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST EnumResourceTypes = EnumResourceTypesW;
<* ELSE *>
      CONST EnumResourceTypes = EnumResourceTypesA;
<* END *>

PROCEDURE EnumResourceNamesA (hModule    : HMODULE;
                              lpType     : RESOURCESTRA;
                              lpEnumFunc : ENUMRESNAMEPROCA;
                              lParam     : LONG) : BOOL;

PROCEDURE EnumResourceNamesW (hModule    : HMODULE;
                              lpType     : RESOURCESTRW;
                              lpEnumFunc : ENUMRESNAMEPROCW;
                              lParam     : LONG) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST EnumResourceNames = EnumResourceNamesW;
<* ELSE *>
      CONST EnumResourceNames = EnumResourceNamesA;
<* END *>

PROCEDURE EnumResourceLanguagesA (hModule    : HMODULE;
                                  lpType     : RESOURCESTRA;
                                  lpName     : RESOURCESTRA;
                                  lpEnumFunc : ENUMRESLANGPROCA;
                                  lParam     : LONG) : BOOL;

PROCEDURE EnumResourceLanguagesW (hModule    : HMODULE;
                                  lpType     : RESOURCESTRW;
                                  lpName     : RESOURCESTRW;
                                  lpEnumFunc : ENUMRESLANGPROCW;
                                  lParam     : LONG) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST EnumResourceLanguages = EnumResourceLanguagesW;
<* ELSE *>
      CONST EnumResourceLanguages = EnumResourceLanguagesA;
<* END *>

PROCEDURE BeginUpdateResourceA (FileName                 : ARRAY OF CHAR;
                                bDeleteExistingResources : BOOL)
                                                                 : HANDLE;

PROCEDURE BeginUpdateResourceW (FileName                 : ARRAY OF WCHAR;
                                bDeleteExistingResources : BOOL)
                                                                 : HANDLE;

<* IF DEFINED (UNICODE) THEN *>
      CONST BeginUpdateResource = BeginUpdateResourceW;
<* ELSE *>
      CONST BeginUpdateResource = BeginUpdateResourceA;
<* END *>

PROCEDURE UpdateResourceA (hUpdate   : HANDLE;
                           lpType    : RESOURCESTRA;
                           lpName    : RESOURCESTRA;
                           wLanguage : WORD;
                           lpData    : PVOID;
                           cbData    : DWORD) : BOOL;

PROCEDURE UpdateResourceW (hUpdate   : HANDLE;
                           lpType    : RESOURCESTRW;
                           lpName    : RESOURCESTRW;
                           wLanguage : WORD;
                           lpData    : PVOID;
                           cbData    : DWORD) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST UpdateResource = UpdateResourceW;
<* ELSE *>
      CONST UpdateResource = UpdateResourceA;
<* END *>

PROCEDURE EndUpdateResourceA (hUpdate  : HANDLE;
                              fDiscard : BOOL) : BOOL;

PROCEDURE EndUpdateResourceW (hUpdate  : HANDLE;
                              fDiscard : BOOL) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST EndUpdateResource = EndUpdateResourceW;
<* ELSE *>
      CONST EndUpdateResource = EndUpdateResourceA;
<* END *>

PROCEDURE GlobalAddAtomA (String : ARRAY OF CHAR)  : ATOM;
PROCEDURE GlobalAddAtomW (String : ARRAY OF WCHAR) : ATOM;

<* IF DEFINED (UNICODE) THEN *>
      CONST GlobalAddAtom = GlobalAddAtomW;
<* ELSE *>
      CONST GlobalAddAtom = GlobalAddAtomA;
<* END *>

PROCEDURE GlobalFindAtomA (String : ARRAY OF CHAR)  : ATOM;
PROCEDURE GlobalFindAtomW (String : ARRAY OF WCHAR) : ATOM;

<* IF DEFINED (UNICODE) THEN *>
      CONST GlobalFindAtom = GlobalFindAtomW;
<* ELSE *>
      CONST GlobalFindAtom = GlobalFindAtomA;
<* END *>

PROCEDURE GlobalGetAtomNameA (nAtom      : ATOM;
                              VAR Buffer : ARRAY OF CHAR;
                              nSize      : INTEGER)
                                                    : UINT;

PROCEDURE GlobalGetAtomNameW (nAtom      : ATOM;
                              VAR Buffer : ARRAY OF WCHAR;
                              nSize      : INTEGER)
                                                    : UINT;

<* IF DEFINED (UNICODE) THEN *>
      CONST GlobalGetAtomName = GlobalGetAtomNameW;
<* ELSE *>
      CONST GlobalGetAtomName = GlobalGetAtomNameA;
<* END *>

PROCEDURE AddAtomA (String : ARRAY OF CHAR)  : ATOM;
PROCEDURE AddAtomW (String : ARRAY OF WCHAR) : ATOM;

<* IF DEFINED (UNICODE) THEN *>
      CONST AddAtom = AddAtomW;
<* ELSE *>
      CONST AddAtom = AddAtomA;
<* END *>

PROCEDURE FindAtomA (String : ARRAY OF CHAR)  : ATOM;
PROCEDURE FindAtomW (String : ARRAY OF WCHAR) : ATOM;

<* IF DEFINED (UNICODE) THEN *>
      CONST FindAtom = FindAtomW;
<* ELSE *>
      CONST FindAtom = FindAtomA;
<* END *>

PROCEDURE GetAtomNameA (nAtom      : ATOM;
                        VAR Buffer : ARRAY OF CHAR;
                        nSize      : INTEGER)
                                              : UINT;

PROCEDURE GetAtomNameW (nAtom      : ATOM;
                        VAR Buffer : ARRAY OF WCHAR;
                        nSize      : INTEGER)
                                              : UINT;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetAtomName = GetAtomNameW;
<* ELSE *>
      CONST GetAtomName = GetAtomNameA;
<* END *>

PROCEDURE GetProfileIntA (AppName  : ARRAY OF CHAR;
                          KeyName  : ARRAY OF CHAR;
                          nDefault : INTEGER)
                                               : UINT;

PROCEDURE GetProfileIntW (AppName  : ARRAY OF WCHAR;
                          KeyName  : ARRAY OF WCHAR;
                          nDefault : INTEGER)
                                              : UINT;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetProfileInt = GetProfileIntW;
<* ELSE *>
      CONST GetProfileInt = GetProfileIntA;
<* END *>

PROCEDURE GetProfileStringA (AppName            : ARRAY OF CHAR;
                             KeyName            : ARRAY OF CHAR;
                             Default            : ARRAY OF CHAR;
                             VAR ReturnedString : ARRAY OF CHAR;
                             nSize              : DWORD)
                                                         : DWORD;

PROCEDURE GetProfileStringW (AppName            : ARRAY OF WCHAR;
                             KeyName            : ARRAY OF WCHAR;
                             Default            : ARRAY OF WCHAR;
                             VAR ReturnedString : ARRAY OF WCHAR;
                             nSize              : DWORD)
                                                         : DWORD;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetProfileString = GetProfileStringW;
<* ELSE *>
      CONST GetProfileString = GetProfileStringA;
<* END *>

PROCEDURE WriteProfileStringA (AppName : ARRAY OF CHAR;
                               KeyName : ARRAY OF CHAR;
                               String  : ARRAY OF CHAR) : BOOL;

PROCEDURE WriteProfileStringW (AppName : ARRAY OF WCHAR;
                               KeyName : ARRAY OF WCHAR;
                               String  : ARRAY OF WCHAR) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST WriteProfileString = WriteProfileStringW;
<* ELSE *>
      CONST WriteProfileString = WriteProfileStringA;
<* END *>

PROCEDURE GetProfileSectionA (AppName            : ARRAY OF CHAR;
                              VAR ReturnedString : ARRAY OF CHAR;
                              nSize              : DWORD) : DWORD;

PROCEDURE GetProfileSectionW (AppName            : ARRAY OF WCHAR;
                              VAR ReturnedString : ARRAY OF WCHAR;
                              nSize              : DWORD) : DWORD;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetProfileSection = GetProfileSectionW;
<* ELSE *>
      CONST GetProfileSection = GetProfileSectionA;
<* END *>

PROCEDURE WriteProfileSectionA (AppName : ARRAY OF CHAR;
                                String  : ARRAY OF CHAR)  : BOOL;

PROCEDURE WriteProfileSectionW (AppName : ARRAY OF WCHAR;
                                String  : ARRAY OF WCHAR) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST WriteProfileSection = WriteProfileSectionW;
<* ELSE *>
      CONST WriteProfileSection = WriteProfileSectionA;
<* END *>

PROCEDURE GetPrivateProfileIntA (AppName  : ARRAY OF CHAR;
                                 KeyName  : ARRAY OF CHAR;
                                 nDefault : INTEGER;
                                 FileName : ARRAY OF CHAR) : UINT;

PROCEDURE GetPrivateProfileIntW (AppName  : ARRAY OF WCHAR;
                                 KeyName  : ARRAY OF WCHAR;
                                 nDefault : INTEGER;
                                 FileName : ARRAY OF WCHAR) : UINT;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetPrivateProfileInt = GetPrivateProfileIntW;
<* ELSE *>
      CONST GetPrivateProfileInt = GetPrivateProfileIntA;
<* END *>

PROCEDURE GetPrivateProfileStringA (AppName            : ARRAY OF CHAR;
                                    KeyName            : ARRAY OF CHAR;
                                    Default            : ARRAY OF CHAR;
                                    VAR ReturnedString : ARRAY OF CHAR;
                                    nSize              : DWORD;
                                    FileName           : ARRAY OF CHAR) : DWORD;

PROCEDURE GetPrivateProfileStringW (AppName            : ARRAY OF WCHAR;
                                    KeyName            : ARRAY OF WCHAR;
                                    Default            : ARRAY OF WCHAR;
                                    VAR ReturnedString : ARRAY OF WCHAR;
                                    nSize              : DWORD;
                                    FileName           : ARRAY OF WCHAR) : DWORD;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetPrivateProfileString = GetPrivateProfileStringW;
<* ELSE *>
      CONST GetPrivateProfileString = GetPrivateProfileStringA;
<* END *>

PROCEDURE WritePrivateProfileStringA (AppName  : ARRAY OF CHAR;
                                      KeyName  : ARRAY OF CHAR;
                                      String   : ARRAY OF CHAR;
                                      FileName : ARRAY OF CHAR) : BOOL;

PROCEDURE WritePrivateProfileStringW (AppName  : ARRAY OF WCHAR;
                                      KeyName  : ARRAY OF WCHAR;
                                      String   : ARRAY OF WCHAR;
                                      FileName : ARRAY OF WCHAR) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST WritePrivateProfileString = WritePrivateProfileStringW;
<* ELSE *>
      CONST WritePrivateProfileString = WritePrivateProfileStringA;
<* END *>

PROCEDURE GetPrivateProfileSectionA (AppName            : ARRAY OF CHAR;
                                     VAR ReturnedString : ARRAY OF CHAR;
                                     nSize              : DWORD;
                                     FileName           : ARRAY OF CHAR) : DWORD;

PROCEDURE GetPrivateProfileSectionW (AppName            : ARRAY OF WCHAR;
                                     VAR ReturnedString : ARRAY OF WCHAR;
                                     nSize              : DWORD;
                                     FileName           : ARRAY OF WCHAR) : DWORD;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetPrivateProfileSection = GetPrivateProfileSectionW;
<* ELSE *>
      CONST GetPrivateProfileSection = GetPrivateProfileSectionA;
<* END *>

PROCEDURE WritePrivateProfileSectionA (AppName  : ARRAY OF CHAR;
                                       String   : ARRAY OF CHAR;
                                       FileName : ARRAY OF CHAR) : BOOL;

PROCEDURE WritePrivateProfileSectionW (AppName  : ARRAY OF WCHAR;
                                       String   : ARRAY OF WCHAR;
                                       FileName : ARRAY OF WCHAR) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST WritePrivateProfileSection = WritePrivateProfileSectionW;
<* ELSE *>
      CONST WritePrivateProfileSection = WritePrivateProfileSectionA;
<* END *>

PROCEDURE GetPrivateProfileSectionNamesA (VAR ReturnBuffer : ARRAY OF CHAR;
                                          nSize            : DWORD;
                                          FileName         : ARRAY OF CHAR) : DWORD;

PROCEDURE GetPrivateProfileSectionNamesW (VAR ReturnBuffer : ARRAY OF WCHAR;
                                          nSize            : DWORD;
                                          FileName         : ARRAY OF WCHAR) : DWORD;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetPrivateProfileSectionNames = GetPrivateProfileSectionNamesW;
<* ELSE *>
      CONST GetPrivateProfileSectionNames = GetPrivateProfileSectionNamesA;
<* END *>

PROCEDURE GetPrivateProfileStructA (Section     : ARRAY OF CHAR;
                                    Key         : ARRAY OF CHAR;
                                    lpStruct    : PVOID;
                                    uSizeStruct : UINT;
                                    File        : ARRAY OF CHAR) : BOOL;

PROCEDURE GetPrivateProfileStructW (Section     : ARRAY OF WCHAR;
                                    Key         : ARRAY OF WCHAR;
                                    lpStruct    : PVOID;
                                    uSizeStruct : UINT;
                                    File        : ARRAY OF WCHAR) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetPrivateProfileStruct = GetPrivateProfileStructW;
<* ELSE *>
      CONST GetPrivateProfileStruct = GetPrivateProfileStructA;
<* END *>

PROCEDURE WritePrivateProfileStructA (Section     : ARRAY OF CHAR;
                                      Key         : ARRAY OF CHAR;
                                      lpStruct    : PVOID;
                                      uSizeStruct : UINT;
                                      File        : ARRAY OF CHAR) : BOOL;

PROCEDURE WritePrivateProfileStructW (Section     : ARRAY OF WCHAR;
                                      Key         : ARRAY OF WCHAR;
                                      lpStruct    : PVOID;
                                      uSizeStruct : UINT;
                                      File        : ARRAY OF WCHAR) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST WritePrivateProfileStruct = WritePrivateProfileStructW;
<* ELSE *>
      CONST WritePrivateProfileStruct = WritePrivateProfileStructA;
<* END *>

PROCEDURE GetDriveTypeA (lpRootPathName : PCSTR)  : DRIVE_TYPE; (* IN NIL *)
PROCEDURE GetDriveTypeW (lpRootPathName : PCWSTR) : DRIVE_TYPE; (* IN NIL *)

<* IF DEFINED (UNICODE) THEN *>
      CONST GetDriveType = GetDriveTypeW;
<* ELSE *>
      CONST GetDriveType = GetDriveTypeA;
<* END *>

PROCEDURE GetSystemDirectoryA (VAR Buffer : ARRAY OF CHAR;  uSize : UINT) : UINT;
PROCEDURE GetSystemDirectoryW (VAR Buffer : ARRAY OF WCHAR; uSize : UINT) : UINT;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetSystemDirectory = GetSystemDirectoryW;
<* ELSE *>
      CONST GetSystemDirectory = GetSystemDirectoryA;
<* END *>

PROCEDURE GetTempPathA (nBufferLength : DWORD; VAR Buffer : ARRAY OF CHAR)  : DWORD;
PROCEDURE GetTempPathW (nBufferLength : DWORD; VAR Buffer : ARRAY OF WCHAR) : DWORD;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetTempPath = GetTempPathW;
<* ELSE *>
      CONST GetTempPath = GetTempPathA;
<* END *>

PROCEDURE GetTempFileNameA (PathName         : ARRAY OF CHAR;
                            PrefixString     : ARRAY OF CHAR;
                            uUnique          : UINT;
                            VAR TempFileName : ARRAY OF CHAR) : UINT;

PROCEDURE GetTempFileNameW (PathName         : ARRAY OF WCHAR;
                            PrefixString     : ARRAY OF WCHAR;
                            uUnique          : UINT;
                            VAR TempFileName : ARRAY OF WCHAR) : UINT;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetTempFileName = GetTempFileNameW;
<* ELSE *>
      CONST GetTempFileName = GetTempFileNameA;
<* END *>

PROCEDURE GetWindowsDirectoryA (VAR Buffer : ARRAY OF CHAR;  uSize : UINT) : UINT;
PROCEDURE GetWindowsDirectoryW (VAR Buffer : ARRAY OF WCHAR; uSize : UINT) : UINT;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetWindowsDirectory = GetWindowsDirectoryW;
<* ELSE *>
      CONST GetWindowsDirectory = GetWindowsDirectoryA;
<* END *>

PROCEDURE SetCurrentDirectoryA (PathName : ARRAY OF CHAR)  : BOOL;
PROCEDURE SetCurrentDirectoryW (PathName : ARRAY OF WCHAR) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST SetCurrentDirectory = SetCurrentDirectoryW;
<* ELSE *>
      CONST SetCurrentDirectory = SetCurrentDirectoryA;
<* END *>

PROCEDURE GetCurrentDirectoryA (nBufferLength : DWORD; VAR Buffer : ARRAY OF CHAR)  : DWORD;
PROCEDURE GetCurrentDirectoryW (nBufferLength : DWORD; VAR Buffer : ARRAY OF WCHAR) : DWORD;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetCurrentDirectory = GetCurrentDirectoryW;
<* ELSE *>
      CONST GetCurrentDirectory = GetCurrentDirectoryA;
<* END *>

PROCEDURE GetDiskFreeSpaceA (lpRootPathName            : PCSTR; (* IN NIL *)
                             VAR SectorsPerCluster     : DWORD;
                             VAR BytesPerSector        : DWORD;
                             VAR NumberOfFreeClusters  : DWORD;
                             VAR TotalNumberOfClusters : DWORD) : BOOL;

PROCEDURE GetDiskFreeSpaceW (lpRootPathName            : PCWSTR; (* IN NIL *)
                             VAR SectorsPerCluster     : DWORD;
                             VAR BytesPerSector        : DWORD;
                             VAR NumberOfFreeClusters  : DWORD;
                             VAR TotalNumberOfClusters : DWORD) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetDiskFreeSpace = GetDiskFreeSpaceW;
<* ELSE *>
      CONST GetDiskFreeSpace = GetDiskFreeSpaceA;
<* END *>

PROCEDURE GetDiskFreeSpaceExA (DirectoryName                    : PCSTR;          (* IN NIL *)
                               VAR lpFreeBytesAvailableToCaller : ULARGE_INTEGER;
                               VAR lpTotalNumberOfBytes         : ULARGE_INTEGER;
                               VAR lpTotalNumberOfFreeBytes     : ULARGE_INTEGER) : BOOL;

PROCEDURE GetDiskFreeSpaceExW (DirectoryName                    : PCWSTR;         (* IN NIL *)
                               VAR lpFreeBytesAvailableToCaller : ULARGE_INTEGER;
                               VAR lpTotalNumberOfBytes         : ULARGE_INTEGER;
                               VAR lpTotalNumberOfFreeBytes     : ULARGE_INTEGER) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetDiskFreeSpaceEx = GetDiskFreeSpaceExW;
<* ELSE *>
      CONST GetDiskFreeSpaceEx = GetDiskFreeSpaceExA;
<* END *>

PROCEDURE CreateDirectoryA (PathName             : ARRAY OF CHAR;
                            lpSecurityAttributes : PSECURITY_ATTRIBUTES) : BOOL;

PROCEDURE CreateDirectoryW (PathName             : ARRAY OF WCHAR;
                            lpSecurityAttributes : PSECURITY_ATTRIBUTES) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST CreateDirectory = CreateDirectoryW;
<* ELSE *>
      CONST CreateDirectory = CreateDirectoryA;
<* END *>

PROCEDURE CreateDirectoryExA (TemplateDirectory    : ARRAY OF CHAR;
                              NewDirectory         : ARRAY OF CHAR;
                              lpSecurityAttributes : PSECURITY_ATTRIBUTES) : BOOL;

PROCEDURE CreateDirectoryExW (TemplateDirectory    : ARRAY OF WCHAR;
                              NewDirectory         : ARRAY OF WCHAR;
                              lpSecurityAttributes : PSECURITY_ATTRIBUTES) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST CreateDirectoryEx = CreateDirectoryExW;
<* ELSE *>
      CONST CreateDirectoryEx = CreateDirectoryExA;
<* END *>

PROCEDURE RemoveDirectoryA (PathName : ARRAY OF CHAR)  : BOOL;
PROCEDURE RemoveDirectoryW (PathName : ARRAY OF WCHAR) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST RemoveDirectory = RemoveDirectoryW;
<* ELSE *>
      CONST RemoveDirectory = RemoveDirectoryA;
<* END *>

PROCEDURE GetFullPathNameA (FileName       : ARRAY OF CHAR;
                            nBufferLength  : DWORD;
                            VAR Buffer     : ARRAY OF CHAR;
                            VAR lpFilePart : PSTR)
                                                   : DWORD;

PROCEDURE GetFullPathNameW (FileName       : ARRAY OF WCHAR;
                            nBufferLength  : DWORD;
                            VAR Buffer     : ARRAY OF WCHAR;
                            VAR lpFilePart : PWSTR)
                                                    : DWORD;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetFullPathName = GetFullPathNameW;
<* ELSE *>
      CONST GetFullPathName = GetFullPathNameA;
<* END *>


TYPE DDD_ENUM = (DDD__RAW_TARGET_PATH,        (* 0 *)
                 DDD__REMOVE_DEFINITION,      (* 1 *)
                 DDD__EXACT_MATCH_ON_REMOVE,  (* 2 *)
                 DDD__NO_BROADCAST_SYSTEM);   (* 3 *)

     DDD_SET = SET OF DDD_ENUM;

CONST DDD_RAW_TARGET_PATH       = DDD_SET {DDD__RAW_TARGET_PATH};       (* 0x00000001 *)
      DDD_REMOVE_DEFINITION     = DDD_SET {DDD__REMOVE_DEFINITION};     (* 0x00000002 *)
      DDD_EXACT_MATCH_ON_REMOVE = DDD_SET {DDD__EXACT_MATCH_ON_REMOVE}; (* 0x00000004 *)
      DDD_NO_BROADCAST_SYSTEM   = DDD_SET {DDD__NO_BROADCAST_SYSTEM};   (* 0x00000008 *)

PROCEDURE DefineDosDeviceA (dwFlags      : DDD_SET;
                            lpDeviceName : ARRAY OF CHAR;
                            lpTargetPath : ARRAY OF CHAR) : BOOL;

PROCEDURE DefineDosDeviceW (dwFlags      : DDD_SET;
                            lpDeviceName : ARRAY OF WCHAR;
                            lpTargetPath : ARRAY OF WCHAR) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST DefineDosDevice = DefineDosDeviceW;
<* ELSE *>
      CONST DefineDosDevice = DefineDosDeviceA;
<* END *>

PROCEDURE QueryDosDeviceA (DeviceName     : ARRAY OF CHAR;
                           VAR TargetPath : ARRAY OF CHAR;
                           ucchMax        : DWORD)
                                                   : DWORD;

PROCEDURE QueryDosDeviceW (DeviceName     : ARRAY OF WCHAR;
                           VAR TargetPath : ARRAY OF WCHAR;
                           ucchMax        : DWORD)
                                                   : DWORD;

<* IF DEFINED (UNICODE) THEN *>
      CONST QueryDosDevice = QueryDosDeviceW;
<* ELSE *>
      CONST QueryDosDevice = QueryDosDeviceA;
<* END *>

PROCEDURE CreateFileA (FileName              : ARRAY OF CHAR;
                       dwDesiredAccess       : ACCESS_MASK;
                       dwShareMode           : FILE_SHARE_MODE;
                       lpSecurityAttributes  : PSECURITY_ATTRIBUTES;
                       dwCreationDisposition : CREATION_DISTRIBUTION;
                       dwFlagsAndAttributes  : FILE_BIT_SET;
                       hTemplateFile         : HANDLE
                                                      ) : HANDLE;

PROCEDURE CreateFileW (FileName              : ARRAY OF WCHAR;
                       dwDesiredAccess       : ACCESS_MASK;
                       dwShareMode           : FILE_SHARE_MODE;
                       lpSecurityAttributes  : PSECURITY_ATTRIBUTES;
                       dwCreationDisposition : CREATION_DISTRIBUTION;
                       dwFlagsAndAttributes  : FILE_BIT_SET;
                       hTemplateFile         : HANDLE
                                                      ) : HANDLE;

<* IF DEFINED (UNICODE) THEN *>
      CONST CreateFile = CreateFileW;
<* ELSE *>
      CONST CreateFile = CreateFileA;
<* END *>

PROCEDURE SetFileAttributesA (lpFileName       : ARRAY OF CHAR;
                              dwFileAttributes : FILE_ATTRIBUTE_SET) : BOOL;

PROCEDURE SetFileAttributesW (lpFileName       : ARRAY OF WCHAR;
                              dwFileAttributes : FILE_ATTRIBUTE_SET) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST SetFileAttributes = SetFileAttributesW;
<* ELSE *>
      CONST SetFileAttributes = SetFileAttributesA;
<* END *>

PROCEDURE GetFileAttributesA (FileName : ARRAY OF CHAR)  : DWORD;
PROCEDURE GetFileAttributesW (FileName : ARRAY OF WCHAR) : DWORD;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetFileAttributes = GetFileAttributesW;
<* ELSE *>
      CONST GetFileAttributes = GetFileAttributesA;
<* END *>

TYPE GET_FILEEX_INFO_LEVELS = (GetFileExInfoStandard,
                               GetFileExMaxInfoLevel);

PROCEDURE GetFileAttributesExA (FileName          : ARRAY OF CHAR;
                                fInfoLevelId      : GET_FILEEX_INFO_LEVELS;
                                lpFileInformation : PVOID)
                                                           : BOOL;

PROCEDURE GetFileAttributesExW (FileName          : ARRAY OF WCHAR;
                                fInfoLevelId      : GET_FILEEX_INFO_LEVELS;
                                lpFileInformation : PVOID)
                                                           : BOOL;
<* IF DEFINED (UNICODE) THEN *>
      CONST GetFileAttributesEx = GetFileAttributesExW;
<* ELSE *>
      CONST GetFileAttributesEx = GetFileAttributesExA;
<* END *>

PROCEDURE GetCompressedFileSizeA (FileName               : ARRAY OF CHAR;
                                  VAR [NIL] FileSizeHigh : DWORD)
                                                                  : DWORD;

PROCEDURE GetCompressedFileSizeW (FileName               : ARRAY OF WCHAR;
                                  VAR [NIL] FileSizeHigh : DWORD)
                                                                   : DWORD;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetCompressedFileSize = GetCompressedFileSizeW;
<* ELSE *>
      CONST GetCompressedFileSize = GetCompressedFileSizeA;
<* END *>

PROCEDURE DeleteFileA (FileName : ARRAY OF CHAR)  : BOOL;
PROCEDURE DeleteFileW (FileName : ARRAY OF WCHAR) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST DeleteFile = DeleteFileW;
<* ELSE *>
      CONST DeleteFile = DeleteFileA;
<* END *>

TYPE FINDEX_INFO_LEVELS = (FindExInfoStandard,
                           FindExInfoMaxInfoLevel);

TYPE FINDEX_SEARCH_OPS = (FindExSearchNameMatch,
                          FindExSearchLimitToDirectories,
                          FindExSearchLimitToDevices,
                          FindExSearchMaxSearchOp);

CONST FIND_FIRST_EX_CASE_SENSITIVE = 1;

PROCEDURE FindFirstFileExA (FileName          : ARRAY OF CHAR;
                            fInfoLevelId      : FINDEX_INFO_LEVELS;
                            lpFindFileData    : PVOID;
                            fSearchOp         : FINDEX_SEARCH_OPS;
                            lpSearchFilter    : PVOID;
                            dwAdditionalFlags : DWORD) : HANDLE;

PROCEDURE FindFirstFileExW (FileName          : ARRAY OF WCHAR;
                            fInfoLevelId      : FINDEX_INFO_LEVELS;
                            lpFindFileData    : PVOID;
                            fSearchOp         : FINDEX_SEARCH_OPS;
                            lpSearchFilter    : PVOID;
                            dwAdditionalFlags : DWORD) : HANDLE;

<* IF DEFINED (UNICODE) THEN *>
      CONST FindFirstFileEx = FindFirstFileExW;
<* ELSE *>
      CONST FindFirstFileEx = FindFirstFileExA;
<* END *>

PROCEDURE FindFirstFileA (FileName         : ARRAY OF CHAR;
                          VAR FindFileData : WIN32_FIND_DATAA) : HANDLE;

PROCEDURE FindFirstFileW (FileName         : ARRAY OF WCHAR;
                          VAR FindFileData : WIN32_FIND_DATAW) : HANDLE;

<* IF DEFINED (UNICODE) THEN *>
      CONST FindFirstFile = FindFirstFileW;
<* ELSE *>
      CONST FindFirstFile = FindFirstFileA;
<* END *>

PROCEDURE FindNextFileA (hFindFile        : HANDLE;
                         VAR FindFileData : WIN32_FIND_DATAA) : BOOL;

PROCEDURE FindNextFileW (hFindFile        : HANDLE;
                         VAR FindFileData : WIN32_FIND_DATAW) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST FindNextFile = FindNextFileW;
<* ELSE *>
      CONST FindNextFile = FindNextFileA;
<* END *>

PROCEDURE SearchPathA (Path           : PCSTR;
                       FileName       : ARRAY OF CHAR;
                       Extension      : PCSTR;
                       nBufferLength  : DWORD;
                       VAR Buffer     : ARRAY OF CHAR;
                       VAR FilePart   : PSTR)
                                              : DWORD;

PROCEDURE SearchPathW (Path           : PCWSTR;
                       FileName       : ARRAY OF WCHAR;
                       Extension      : PCWSTR;
                       nBufferLength  : DWORD;
                       VAR Buffer     : ARRAY OF WCHAR;
                       VAR FilePart   : PWSTR)
                                               : DWORD;

<* IF DEFINED (UNICODE) THEN *>
      CONST SearchPath = SearchPathW;
<* ELSE *>
      CONST SearchPath = SearchPathA;
<* END *>

PROCEDURE CopyFileA (ExistingFileName : ARRAY OF CHAR;
                     NewFileName      : ARRAY OF CHAR;
                     bFailIfExists    : BOOL)
                                              : BOOL;

PROCEDURE CopyFileW (ExistingFileName : ARRAY OF WCHAR;
                     NewFileName      : ARRAY OF WCHAR;
                     bFailIfExists    : BOOL)
                                              : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST CopyFile = CopyFileW;
<* ELSE *>
      CONST CopyFile = CopyFileA;
<* END *>

(* Attention!
   Orinnally this callback function took LARGE_INTEGER parameters.
   For example, originally two firstparameters were declared as
       (* TotalFileSize          : *) LARGE_INTEGER,
       (* TotalBytesTransferred  : *) LARGE_INTEGER
   Unfortunately, XDS Modula-2 does not support structures being
   passed by value to STACALL functions.
   So pair of parameters, high and low parts, provided instead of each
   LARGE_INTEGER. The STDCALL calling convention ensures that LARGE_INTEGER
   structure passed by the system will be received properly by callback
   function
*)

TYPE LPPROGRESS_ROUTINE = PROCEDURE ((* TotalFileSizeLow           : *) DWORD,
                                     (* TotalFileSizeHigh          : *) DWORD,
                                     (* TotalBytesTransferredLow   : *) DWORD,
                                     (* TotalBytesTransferredHigh  : *) DWORD,
                                     (* StreamSizeLow              : *) DWORD,
                                     (* StreamSizeHigh             : *) DWORD,
                                     (* StreamBytesTransferredLow  : *) DWORD,
                                     (* StreamBytesTransferredHigh : *) DWORD,
                                     (* dwStreamNumber             : *) DWORD,
                                     (* dwCallbackReason           : *) COPYFILEEX_CALLBACK_ENUM,
                                     (* hSourceFile                : *) HANDLE,
                                     (* hDestinationFile           : *) HANDLE,
                                     (* lpData                     : *) PVOID) : PROGRESS_ENUM;

PROCEDURE CopyFileExA (ExistingFileName  : ARRAY OF CHAR;
                       NewFileName       : ARRAY OF CHAR;
                       lpProgressRoutine : LPPROGRESS_ROUTINE;
                       lpData            : PVOID;
                       VAR pbCancel      : BOOL;
                       dwCopyFlags       : COPY_FILE_SET) : BOOL;

PROCEDURE CopyFileExW (ExistingFileName  : ARRAY OF WCHAR;
                       NewFileName       : ARRAY OF WCHAR;
                       lpProgressRoutine : LPPROGRESS_ROUTINE;
                       lpData            : PVOID;
                       VAR pbCancel      : BOOL;
                       dwCopyFlags       : COPY_FILE_SET) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST CopyFileEx = CopyFileExW;
<* ELSE *>
      CONST CopyFileEx = CopyFileExA;
<* END *>

PROCEDURE MoveFileA (ExistingFileName : ARRAY OF CHAR;
                     NewFileName      : ARRAY OF CHAR) : BOOL;

PROCEDURE MoveFileW (ExistingFileName : ARRAY OF WCHAR;
                     NewFileName      : ARRAY OF WCHAR) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST MoveFile = MoveFileW;
<* ELSE *>
      CONST MoveFile = MoveFileA;
<* END *>

TYPE MOVEFILE_ENUM = (MOVEFILE__REPLACE_EXISTING,    (* 0 *)
                      MOVEFILE__COPY_ALLOWED,        (* 1 *)
                      MOVEFILE__DELAY_UNTIL_REBOOT,  (* 2 *)
                      MOVEFILE__WRITE_THROUGH);      (* 3 *)

     MOVEFILE_SET = SET OF MOVEFILE_ENUM;


CONST MOVEFILE_REPLACE_EXISTING   = MOVEFILE_SET {MOVEFILE__REPLACE_EXISTING  }; (* 0x00000001 *)
      MOVEFILE_COPY_ALLOWED       = MOVEFILE_SET {MOVEFILE__COPY_ALLOWED      }; (* 0x00000002 *)
      MOVEFILE_DELAY_UNTIL_REBOOT = MOVEFILE_SET {MOVEFILE__DELAY_UNTIL_REBOOT}; (* 0x00000004 *)
      MOVEFILE_WRITE_THROUGH      = MOVEFILE_SET {MOVEFILE__WRITE_THROUGH     }; (* 0x00000008 *)

PROCEDURE MoveFileExA (ExistingFileName : ARRAY OF CHAR;
                       NewFileName      : ARRAY OF CHAR;
                       dwFlags          : MOVEFILE_SET) : BOOL;

PROCEDURE MoveFileExW (ExistingFileName : ARRAY OF WCHAR;
                       NewFileName      : ARRAY OF WCHAR;
                       dwFlags          : MOVEFILE_SET) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST MoveFileEx = MoveFileExW;
<* ELSE *>
      CONST MoveFileEx = MoveFileExA;
<* END *>

PROCEDURE CreateNamedPipeA (Name                 : ARRAY OF CHAR;
                            dwOpenMode           : FILE_BIT_SET;
                            dwPipeMode           : PIPE_MODE_SET;
                            nMaxInstances        : DWORD;
                            nOutBufferSize       : DWORD;
                            nInBufferSize        : DWORD;
                            nDefaultTimeOut      : DWORD;
                            lpSecurityAttributes : PSECURITY_ATTRIBUTES
                ) : HANDLE;

PROCEDURE CreateNamedPipeW (Name                 : ARRAY OF WCHAR;
                            dwOpenMode           : FILE_BIT_SET;
                            dwPipeMode           : PIPE_MODE_SET;
                            nMaxInstances        : DWORD;
                            nOutBufferSize       : DWORD;
                            nInBufferSize        : DWORD;
                            nDefaultTimeOut      : DWORD;
                            lpSecurityAttributes : PSECURITY_ATTRIBUTES
                ) : HANDLE;

<* IF DEFINED (UNICODE) THEN *>
      CONST CreateNamedPipe = CreateNamedPipeW;
<* ELSE *>
      CONST CreateNamedPipe = CreateNamedPipeA;
<* END *>

PROCEDURE GetNamedPipeHandleStateA (hNamedPipe                   : HANDLE;
                                    VAR [NIL] State              : PIPE_MODE_SET;
                                    VAR [NIL] CurInstances       : DWORD;
                                    VAR [NIL] MaxCollectionCount : DWORD;
                                    VAR [NIL] CollectDataTimeout : DWORD;
                                    VAR [NIL] UserName           : ARRAY OF CHAR;
                                    nMaxUserNameSize             : DWORD) : BOOL;

PROCEDURE GetNamedPipeHandleStateW (hNamedPipe                   : HANDLE;
                                    VAR [NIL] State              : PIPE_MODE_SET;
                                    VAR [NIL] CurInstances       : DWORD;
                                    VAR [NIL] MaxCollectionCount : DWORD;
                                    VAR [NIL] CollectDataTimeout : DWORD;
                                    VAR [NIL] UserName           : ARRAY OF WCHAR;
                                    nMaxUserNameSize             : DWORD) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetNamedPipeHandleState = GetNamedPipeHandleStateW;
<* ELSE *>
      CONST GetNamedPipeHandleState = GetNamedPipeHandleStateA;
<* END *>

PROCEDURE CallNamedPipeA (lpNamedPipeName : ARRAY OF CHAR;
                          lpInBuffer      : PVOID;
                          nInBufferSize   : DWORD;
                          lpOutBuffer     : PVOID;
                          nOutBufferSize  : DWORD;
                          VAR lpBytesRead : DWORD;
                          nTimeOut        : DWORD) : BOOL;

PROCEDURE CallNamedPipeW (lpNamedPipeName : ARRAY OF WCHAR;
                          lpInBuffer      : PVOID;
                          nInBufferSize   : DWORD;
                          lpOutBuffer     : PVOID;
                          nOutBufferSize  : DWORD;
                          VAR lpBytesRead : DWORD;
                          nTimeOut        : DWORD) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST CallNamedPipe = CallNamedPipeW;
<* ELSE *>
      CONST CallNamedPipe = CallNamedPipeA;
<* END *>

PROCEDURE WaitNamedPipeA (NamedPipeName : ARRAY OF CHAR;
                          nTimeOut      : DWORD) : BOOL;

PROCEDURE WaitNamedPipeW (NamedPipeName : ARRAY OF WCHAR;
                          nTimeOut      : DWORD) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST WaitNamedPipe = WaitNamedPipeW;
<* ELSE *>
      CONST WaitNamedPipe = WaitNamedPipeA;
<* END *>

PROCEDURE SetVolumeLabelA (lpRootPathName : PCSTR;          (* IN NIL *)
                           lpVolumeName   : PCSTR) : BOOL;  (* IN NIL *)

PROCEDURE SetVolumeLabelW (lpRootPathName : PCWSTR;         (* IN NIL *)
                           lpVolumeName   : PCWSTR) : BOOL; (* IN NIL *)

<* IF DEFINED (UNICODE) THEN *>
      CONST SetVolumeLabel = SetVolumeLabelW;
<* ELSE *>
      CONST SetVolumeLabel = SetVolumeLabelA;
<* END *>

PROCEDURE SetFileApisToOEM;
PROCEDURE SetFileApisToANSI;
PROCEDURE AreFileApisANSI () : BOOL;

PROCEDURE GetVolumeInformationA (lpRootPathName               : PCSTR; (* IN NIL *)
                                 VAR VolumeNameBuffer         : ARRAY OF CHAR;
                                 nVolumeNameSize              : DWORD;
                                 VAR [NIL] VolumeSerialNumber : DWORD;
                                 VAR MaximumComponentLength   : DWORD;
                                 VAR FileSystemFlags          : FILESYSTEM_FLAGS;
                                 VAR FileSystemNameBuffer     : ARRAY OF CHAR;
                                 nFileSystemNameSize          : DWORD) : BOOL;

PROCEDURE GetVolumeInformationW (lpRootPathName               : PCWSTR; (* IN NIL *)
                                 VAR VolumeNameBuffer         : ARRAY OF WCHAR;
                                 nVolumeNameSize              : DWORD;
                                 VAR [NIL] VolumeSerialNumber : DWORD;
                                 VAR MaximumComponentLength   : DWORD;
                                 VAR FileSystemFlags          : FILESYSTEM_FLAGS;
                                 VAR FileSystemNameBuffer     : ARRAY OF WCHAR;
                                 nFileSystemNameSize          : DWORD) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetVolumeInformation = GetVolumeInformationW;
<* ELSE *>
      CONST GetVolumeInformation = GetVolumeInformationA;
<* END *>

PROCEDURE CancelIo (hFile : HANDLE) : BOOL;

(*
** Event logging APIs
*)

PROCEDURE ClearEventLogA (hEventLog        : HANDLE;
                          lpBackupFileName : PCSTR) : BOOL;  (* IN NIL *)

PROCEDURE ClearEventLogW (hEventLog        : HANDLE;
                          lpBackupFileName : PCWSTR) : BOOL; (* IN NIL *)

<* IF DEFINED (UNICODE) THEN *>
      CONST ClearEventLog = ClearEventLogW;
<* ELSE *>
      CONST ClearEventLog = ClearEventLogA;
<* END *>

PROCEDURE BackupEventLogA (hEventLog        : HANDLE;
                           lpBackupFileName : ARRAY OF CHAR) : BOOL;

PROCEDURE BackupEventLogW (hEventLog        : HANDLE;
                           lpBackupFileName : ARRAY OF WCHAR) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST BackupEventLog = BackupEventLogW;
<* ELSE *>
      CONST BackupEventLog = BackupEventLogA;
<* END *>

PROCEDURE CloseEventLog (hEventLog : HANDLE) : BOOL;
PROCEDURE DeregisterEventSource (hEventLog : HANDLE) : BOOL;

PROCEDURE NotifyChangeEventLog (hEventLog : HANDLE;
                                hEvent    : HANDLE) : BOOL;

PROCEDURE GetNumberOfEventLogRecords (hEventLog           : HANDLE;
                                      VAR NumberOfRecords : DWORD) : BOOL;

PROCEDURE GetOldestEventLogRecord (hEventLog : HANDLE;
                                   VAR OldestRecord : DWORD) : BOOL;

PROCEDURE OpenEventLogA (lpUNCServerName : PCSTR; (* IN NIL *)
                         lpSourceName    : ARRAY OF CHAR) : HANDLE;

PROCEDURE OpenEventLogW (lpUNCServerName : PCWSTR; (* IN NIL *)
                         lpSourceName    : ARRAY OF WCHAR) : HANDLE;

<* IF DEFINED (UNICODE) THEN *>
      CONST OpenEventLog = OpenEventLogW;
<* ELSE *>
      CONST OpenEventLog = OpenEventLogA;
<* END *>

PROCEDURE RegisterEventSourceA (lpUNCServerName : PCSTR; (* NIL *)
                                lpSourceName    : ARRAY OF CHAR) : HANDLE;

PROCEDURE RegisterEventSourceW (lpUNCServerName : PCWSTR; (* NIL *)
                                lpSourceName    : ARRAY OF WCHAR) : HANDLE;

<* IF DEFINED (UNICODE) THEN *>
      CONST RegisterEventSource = RegisterEventSourceW;
<* ELSE *>
      CONST RegisterEventSource = RegisterEventSourceA;
<* END *>

PROCEDURE OpenBackupEventLogA (lpUNCServerName : PCSTR;  (* NIL *)
                               lpFileName      : ARRAY OF CHAR) : HANDLE;

PROCEDURE OpenBackupEventLogW (lpUNCServerName : PCWSTR;  (* NIL *)
                               lpFileName      : ARRAY OF WCHAR) : HANDLE;

<* IF DEFINED (UNICODE) THEN *>
      CONST OpenBackupEventLog = OpenBackupEventLogW;
<* ELSE *>
      CONST OpenBackupEventLog = OpenBackupEventLogA;
<* END *>

PROCEDURE ReadEventLogA (hEventLog                  : HANDLE;
                         dwReadFlags                : EVENTLOG_READ_SET;
                         dwRecordOffset             : DWORD;
                         lpBuffer                   : PVOID;
                         nNumberOfBytesToRead       : DWORD;
                         VAR BytesRead              : DWORD;
                         VAR MinNumberOfBytesNeeded : DWORD) : BOOL;

PROCEDURE ReadEventLogW (hEventLog                  : HANDLE;
                         dwReadFlags                : EVENTLOG_READ_SET;
                         dwRecordOffset             : DWORD;
                         lpBuffer                   : PVOID;
                         nNumberOfBytesToRead       : DWORD;
                         VAR BytesRead              : DWORD;
                         VAR MinNumberOfBytesNeeded : DWORD) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST ReadEventLog = ReadEventLogW;
<* ELSE *>
      CONST ReadEventLog = ReadEventLogA;
<* END *>

PROCEDURE ReportEventA (hEventLog   : HANDLE;
                        wType       : EVENTLOG_TYPE;
                        wCategory   : WORD;
                        dwEventID   : DWORD;
                        lpUserSid   : PSID;
                        wNumStrings : WORD;
                        dwDataSize  : DWORD;
                        Strings     : ARRAY OF PCSTR;
                        lpRawData   : PVOID)
                                             : BOOL;

PROCEDURE ReportEventW (hEventLog   : HANDLE;
                        wType       : EVENTLOG_TYPE;
                        wCategory   : WORD;
                        dwEventID   : DWORD;
                        lpUserSid   : PSID;
                        wNumStrings : WORD;
                        dwDataSize  : DWORD;
                        Strings     : ARRAY OF PCWSTR;
                        lpRawData   : PVOID)
                                             : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST ReportEvent = ReportEventW;
<* ELSE *>
      CONST ReportEvent = ReportEventA;
<* END *>

(*
** Security APIs
*)

PROCEDURE DuplicateToken (ExistingTokenHandle      : HANDLE;
                          ImpersonationLevel       : SECURITY_IMPERSONATION_LEVEL;
                          VAR DuplicateTokenHandle : HANDLE) : BOOL;

PROCEDURE GetKernelObjectSecurity (Handle               : HANDLE;
                                   RequestedInformation : SECURITY_INFORMATION;
                                   pSecurityDescriptor  : PSECURITY_DESCRIPTOR;
                                   nLength              : DWORD;
                                   VAR lpnLengthNeeded  : DWORD) : BOOL;

PROCEDURE ImpersonateNamedPipeClient (hNamedPipe : HANDLE) : BOOL;
PROCEDURE ImpersonateSelf (ImpersonationLevel : SECURITY_IMPERSONATION_LEVEL) : BOOL;
PROCEDURE RevertToSelf () : BOOL;
PROCEDURE SetThreadToken (VAR [NIL] Thread : HANDLE;         (* IN *)
                          Token            : HANDLE) : BOOL;

<* IF BACKEND # "C" THEN *>
PROCEDURE AccessCheck (pSecurityDescriptor    : PSECURITY_DESCRIPTOR;
                       ClientToken            : HANDLE;
                       DesiredAccess          : ACCESS_MASK;
                       GenericMapping         : GENERIC_MAPPING; (*!*)
                       VAR PrivilegeSet       : PRIVILEGE_SET;   (*!*)
                       VAR PrivilegeSetLength : DWORD;
                       VAR GrantedAccess      : ACCESS_MASK;
                       VAR AccessStatus       : BOOL)
                                                      : BOOL;
<* ELSE *>
PROCEDURE AccessCheck (pSecurityDescriptor    : PSECURITY_DESCRIPTOR;
                       ClientToken            : HANDLE;
                       DesiredAccess          : ACCESS_MASK;
                       GenericMapping         : PGENERIC_MAPPING; (*!*)
                       VAR PrivilegeSet       : PRIVILEGE_SET;   (*!*)
                       VAR PrivilegeSetLength : DWORD;
                       VAR GrantedAccess      : ACCESS_MASK;
                       VAR AccessStatus       : BOOL)
                                                      : BOOL;
<* END *>

PROCEDURE OpenProcessToken (ProcessHandle   : HANDLE;
                            DesiredAccess   : ACCESS_MASK;
                            VAR TokenHandle : HANDLE) : BOOL;

PROCEDURE OpenThreadToken (ThreadHandle    : HANDLE;
                           DesiredAccess   : ACCESS_MASK;
                           OpenAsSelf      : BOOL;
                           VAR TokenHandle : HANDLE) : BOOL;

PROCEDURE GetTokenInformation (TokenHandle            : HANDLE;
                               TokenInformationClass  : TOKEN_INFORMATION_CLASS;
                               TokenInformation       : PVOID;
                               TokenInformationLength : DWORD;
                               VAR ReturnLength       : DWORD) : BOOL;

PROCEDURE SetTokenInformation (TokenHandle            : HANDLE;
                               TokenInformationClass  : TOKEN_INFORMATION_CLASS;
                               TokenInformation       : PVOID;
                               TokenInformationLength : DWORD)
                                                               : BOOL;

PROCEDURE AdjustTokenPrivileges (TokenHandle             : HANDLE;
                                 DisableAllPrivileges    : BOOL;
                                 VAR [NIL] NewState      : TOKEN_PRIVILEGES;
                                 BufferLength            : DWORD;
                                 VAR [NIL] PreviousState : TOKEN_PRIVILEGES;
                                 VAR [NIL] ReturnLength  : DWORD)
                                                                  : BOOL;

PROCEDURE AdjustTokenGroups (TokenHandle             : HANDLE;
                             ResetToDefault          : BOOL;
                             VAR [NIL] NewState      : TOKEN_GROUPS;
                             BufferLength            : DWORD;
                             VAR [NIL] PreviousState : TOKEN_GROUPS;
                             VAR [NIL] ReturnLength  : DWORD) : BOOL;

PROCEDURE PrivilegeCheck (ClientToken            : HANDLE;
                          VAR RequiredPrivileges : PRIVILEGE_SET;
                          VAR Result             : BOOL)
                                                         : BOOL;

<* IF BACKEND # "C" THEN *>
PROCEDURE AccessCheckAndAuditAlarmA (SubsystemName      : ARRAY OF CHAR;
                                     HandleId           : PVOID;
                                     ObjectTypeName     : ARRAY OF CHAR;
                                     ObjectName         : ARRAY OF CHAR;
                                     SecurityDescriptor : PSECURITY_DESCRIPTOR;
                                     DesiredAccess      : ACCESS_MASK;
                                     GenericMapping     : GENERIC_MAPPING; (*!*)
                                     ObjectCreation     : BOOL;
                                     VAR GrantedAccess  : ACCESS_MASK;
                                     VAR AccessStatus   : BOOL;
                                     VAR GenerateOnClose: BOOL) : BOOL;
<* ELSE *>
PROCEDURE AccessCheckAndAuditAlarmA (SubsystemName      : ARRAY OF CHAR;
                                     HandleId           : PVOID;
                                     ObjectTypeName     : ARRAY OF CHAR;
                                     ObjectName         : ARRAY OF CHAR;
                                     SecurityDescriptor : PSECURITY_DESCRIPTOR;
                                     DesiredAccess      : ACCESS_MASK;
                                     GenericMapping     : PGENERIC_MAPPING; (*!*)
                                     ObjectCreation     : BOOL;
                                     VAR GrantedAccess  : ACCESS_MASK;
                                     VAR AccessStatus   : BOOL;
                                     VAR GenerateOnClose: BOOL) : BOOL;
<* END *>

<* IF BACKEND # "C" THEN *>
PROCEDURE AccessCheckAndAuditAlarmW (SubsystemName      : ARRAY OF WCHAR;
                                     HandleId           : PVOID;
                                     ObjectTypeName     : ARRAY OF WCHAR;
                                     ObjectName         : ARRAY OF WCHAR;
                                     SecurityDescriptor : PSECURITY_DESCRIPTOR;
                                     DesiredAccess      : ACCESS_MASK;
                                     GenericMapping     : GENERIC_MAPPING; (*!*)
                                     ObjectCreation     : BOOL;
                                     VAR GrantedAccess  : ACCESS_MASK;
                                     VAR AccessStatus   : BOOL;
                                     VAR GenerateOnClose: BOOL) : BOOL;
<* ELSE *>
PROCEDURE AccessCheckAndAuditAlarmW (SubsystemName      : ARRAY OF WCHAR;
                                     HandleId           : PVOID;
                                     ObjectTypeName     : ARRAY OF WCHAR;
                                     ObjectName         : ARRAY OF WCHAR;
                                     SecurityDescriptor : PSECURITY_DESCRIPTOR;
                                     DesiredAccess      : ACCESS_MASK;
                                     GenericMapping     : PGENERIC_MAPPING; (*!*)
                                     ObjectCreation     : BOOL;
                                     VAR GrantedAccess  : ACCESS_MASK;
                                     VAR AccessStatus   : BOOL;
                                     VAR GenerateOnClose: BOOL) : BOOL;
<* END *>

<* IF DEFINED (UNICODE) THEN *>
      CONST AccessCheckAndAuditAlarm = AccessCheckAndAuditAlarmW;
<* ELSE *>
      CONST AccessCheckAndAuditAlarm = AccessCheckAndAuditAlarmA;
<* END *>

PROCEDURE ObjectOpenAuditAlarmA (SubsystemName       : ARRAY OF CHAR;
                                 HandleId            : PVOID;
                                 ObjectTypeName      : ARRAY OF CHAR;
                                 ObjectName          : ARRAY OF CHAR;
                                 pSecurityDescriptor : PSECURITY_DESCRIPTOR;
                                 ClientToken         : HANDLE;
                                 DesiredAccess       : ACCESS_MASK;
                                 GrantedAccess       : ACCESS_MASK;
                                 Privileges          : PPRIVILEGE_SET; (* IN NIL *)
                                 ObjectCreation      : BOOL;
                                 AccessGranted       : BOOL;
                                 VAR GenerateOnClose : BOOL) : BOOL;

PROCEDURE ObjectOpenAuditAlarmW (SubsystemName       : ARRAY OF WCHAR;
                                 HandleId            : PVOID;
                                 ObjectTypeName      : ARRAY OF WCHAR;
                                 ObjectName          : ARRAY OF WCHAR;
                                 pSecurityDescriptor : PSECURITY_DESCRIPTOR;
                                 ClientToken         : HANDLE;
                                 DesiredAccess       : ACCESS_MASK;
                                 GrantedAccess       : ACCESS_MASK;
                                 Privileges          : PPRIVILEGE_SET; (* IN NIL *)
                                 ObjectCreation      : BOOL;
                                 AccessGranted       : BOOL;
                                 VAR GenerateOnClose : BOOL) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST ObjectOpenAuditAlarm = ObjectOpenAuditAlarmW;
<* ELSE *>
      CONST ObjectOpenAuditAlarm = ObjectOpenAuditAlarmA;
<* END *>

PROCEDURE ObjectPrivilegeAuditAlarmA (SubsystemName : ARRAY OF CHAR;
                                      HandleId      : PVOID;
                                      ClientToken   : HANDLE;
                                      DesiredAccess : ACCESS_MASK;
                                      Privileges    : PPRIVILEGE_SET; (* IN NIL *)
                                      AccessGranted : BOOL) : BOOL;

PROCEDURE ObjectPrivilegeAuditAlarmW (SubsystemName : ARRAY OF WCHAR;
                                      HandleId      : PVOID;
                                      ClientToken   : HANDLE;
                                      DesiredAccess : ACCESS_MASK;
                                      Privileges    : PPRIVILEGE_SET; (* IN NIL *)
                                      AccessGranted : BOOL) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST ObjectPrivilegeAuditAlarm = ObjectPrivilegeAuditAlarmW;
<* ELSE *>
      CONST ObjectPrivilegeAuditAlarm = ObjectPrivilegeAuditAlarmA;
<* END *>

PROCEDURE ObjectCloseAuditAlarmA (SubsystemName   : ARRAY OF CHAR;
                                  HandleId        : PVOID;
                                  GenerateOnClose : BOOL) : BOOL;

PROCEDURE ObjectCloseAuditAlarmW (SubsystemName   : ARRAY OF WCHAR;
                                  HandleId        : PVOID;
                                  GenerateOnClose : BOOL) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST ObjectCloseAuditAlarm = ObjectCloseAuditAlarmW;
<* ELSE *>
      CONST ObjectCloseAuditAlarm = ObjectCloseAuditAlarmA;
<* END *>

PROCEDURE ObjectDeleteAuditAlarmA (SubsystemName   : ARRAY OF CHAR;
                                   HandleId        : PVOID;
                                   GenerateOnClose : BOOL) : BOOL;

PROCEDURE ObjectDeleteAuditAlarmW (SubsystemName   : ARRAY OF WCHAR;
                                   HandleId        : PVOID;
                                   GenerateOnClose : BOOL) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST ObjectDeleteAuditAlarm = ObjectDeleteAuditAlarmW;
<* ELSE *>
      CONST ObjectDeleteAuditAlarm = ObjectDeleteAuditAlarmA;
<* END *>

<* IF BACKEND # "C" THEN *>
PROCEDURE PrivilegedServiceAuditAlarmA (SubsystemName : ARRAY OF CHAR;
                                        ServiceName   : ARRAY OF CHAR;
                                        ClientToken   : HANDLE;
                                        Privileges    : PRIVILEGE_SET; (*!*)
                                        AccessGranted : BOOL) : BOOL;
<* ELSE *>
PROCEDURE PrivilegedServiceAuditAlarmA (SubsystemName : ARRAY OF CHAR;
                                        ServiceName   : ARRAY OF CHAR;
                                        ClientToken   : HANDLE;
                                        Privileges    : PPRIVILEGE_SET; (*!*)
                                        AccessGranted : BOOL) : BOOL;
<* END *>

<* IF BACKEND # "C" THEN *>
PROCEDURE PrivilegedServiceAuditAlarmW (SubsystemName : ARRAY OF WCHAR;
                                        ServiceName   : ARRAY OF WCHAR;
                                        ClientToken   : HANDLE;
                                        Privileges    : PRIVILEGE_SET; (*!*)
                                        AccessGranted : BOOL) : BOOL;
<* ELSE *>
PROCEDURE PrivilegedServiceAuditAlarmW (SubsystemName : ARRAY OF WCHAR;
                                        ServiceName   : ARRAY OF WCHAR;
                                        ClientToken   : HANDLE;
                                        Privileges    : PPRIVILEGE_SET; (*!*)
                                        AccessGranted : BOOL) : BOOL;
<* END *>

<* IF DEFINED (UNICODE) THEN *>
      CONST PrivilegedServiceAuditAlarm = PrivilegedServiceAuditAlarmW;
<* ELSE *>
      CONST PrivilegedServiceAuditAlarm = PrivilegedServiceAuditAlarmA;
<* END *>

PROCEDURE IsValidSid (pSid : PSID) : BOOL;
PROCEDURE EqualSid (pSid1, pSid2 : PSID) : BOOL;
PROCEDURE EqualPrefixSid (pSid1, pSid2 : PSID) : BOOL;
PROCEDURE GetSidLengthRequired (nSubAuthorityCount : CARD8) : DWORD;

<* IF BACKEND # "C" THEN *>
PROCEDURE AllocateAndInitializeSid (IdentifierAuthority : SID_IDENTIFIER_AUTHORITY; (*!*)
                                    nSubAuthorityCount  : CARD8;
                                    nSubAuthority0      : DWORD;
                                    nSubAuthority1      : DWORD;
                                    nSubAuthority2      : DWORD;
                                    nSubAuthority3      : DWORD;
                                    nSubAuthority4      : DWORD;
                                    nSubAuthority5      : DWORD;
                                    nSubAuthority6      : DWORD;
                                    nSubAuthority7      : DWORD;
                                    VAR pSid            : PSID) : BOOL;
<* ELSE *>
PROCEDURE AllocateAndInitializeSid (IdentifierAuthority : PSID_IDENTIFIER_AUTHORITY; (*!*)
                                    nSubAuthorityCount  : CARD8;
                                    nSubAuthority0      : DWORD;
                                    nSubAuthority1      : DWORD;
                                    nSubAuthority2      : DWORD;
                                    nSubAuthority3      : DWORD;
                                    nSubAuthority4      : DWORD;
                                    nSubAuthority5      : DWORD;
                                    nSubAuthority6      : DWORD;
                                    nSubAuthority7      : DWORD;
                                    VAR pSid            : PSID) : BOOL;
<* END *>

PROCEDURE FreeSid (pSid : PSID) : PVOID;

<* IF BACKEND # "C" THEN *>
PROCEDURE InitializeSid (Sid                 : PSID;
                         IdentifierAuthority : SID_IDENTIFIER_AUTHORITY; (*!*)
                         nSubAuthorityCount  : CARD8) : BOOL;
<* ELSE *>
PROCEDURE InitializeSid (Sid                 : PSID;
                         IdentifierAuthority : PSID_IDENTIFIER_AUTHORITY; (*!*)
                         nSubAuthorityCount  : CARD8) : BOOL;
<* END *>
PROCEDURE GetSidIdentifierAuthority (pSid : PSID) : PSID_IDENTIFIER_AUTHORITY;
PROCEDURE GetSidSubAuthority (pSid : PSID; nSubAuthority : DWORD) : PDWORD;
PROCEDURE GetSidSubAuthorityCount (pSid : PSID) : PCARD8;
PROCEDURE GetLengthSid (pSid : PSID) : DWORD;
PROCEDURE CopySid (nDestinationSidLength : DWORD;
                   pDestinationSid       : PSID;
                   pSourceSid            : PSID) : BOOL;

PROCEDURE AreAllAccessesGranted (GrantedAccess, DesiredAccess : ACCESS_MASK) : BOOL;
PROCEDURE AreAnyAccessesGranted (GrantedAccess, DesiredAccess : ACCESS_MASK) : BOOL;
<* IF BACKEND # "C" THEN *>
PROCEDURE MapGenericMask (VAR AccessMask : ACCESS_MASK;
                          GenericMapping : GENERIC_MAPPING);
<* ELSE *>
PROCEDURE MapGenericMask (VAR AccessMask : ACCESS_MASK;
                          GenericMapping : PGENERIC_MAPPING);
<* END *> (*!*)

PROCEDURE IsValidAcl (VAR Acl : ACL) : BOOL;

PROCEDURE InitializeAcl (VAR Acl       : ACL;
                         nAclLength    : DWORD;
                         dwAclRevision : DWORD) : BOOL;

<* IF BACKEND # "C" THEN *>
PROCEDURE GetAclInformation (Acl                   : ACL; (*!*)
                             pAclInformation       : PVOID;
                             nAclInformationLength : DWORD;
                             dwAclInformationClass : ACL_INFORMATION_CLASS) : BOOL;
<* ELSE *>
PROCEDURE GetAclInformation (Acl                   : PACL; (*!*)
                             pAclInformation       : PVOID;
                             nAclInformationLength : DWORD;
                             dwAclInformationClass : ACL_INFORMATION_CLASS) : BOOL;
<* END *>

PROCEDURE SetAclInformation (VAR Acl               : ACL; (*!*)
                             pAclInformation       : PVOID;
                             nAclInformationLength : DWORD;
                             dwAclInformationClass : ACL_INFORMATION_CLASS) : BOOL;


PROCEDURE AddAce (VAR Acl            : ACL;
                  dwAceRevision      : DWORD;
                  dwStartingAceIndex : DWORD;
                  pAceList           : PVOID;
                  nAceListLength     : DWORD) : BOOL;

PROCEDURE DeleteAce (VAR Acl : ACL; dwAceIndex : DWORD) : BOOL;

PROCEDURE GetAce (VAR Acl    : ACL;
                  dwAceIndex : DWORD;
                  VAR Ace    : PVOID) : BOOL;

PROCEDURE AddAccessAllowedAce (VAR Acl       : ACL;
                               dwAceRevision : DWORD;
                               AccessMask    : ACCESS_MASK;
                               pSid          : PSID) : BOOL;

PROCEDURE AddAccessDeniedAce (VAR Acl       : ACL;
                              dwAceRevision : DWORD;
                              AccessMask    : ACCESS_MASK;
                              pSid          : PSID) : BOOL;

PROCEDURE AddAuditAccessAce (VAR pAcl      : ACL;
                             dwAceRevision : DWORD;
                             dwAccessMask  : ACCESS_MASK;
                             pSid          : PSID;
                             bAuditSuccess : BOOL;
                             bAuditFailure : BOOL) : BOOL;

PROCEDURE FindFirstFreeAce (VAR Acl : ACL; VAR pAce : PVOID) : BOOL;

PROCEDURE InitializeSecurityDescriptor (pSecurityDescriptor : PSECURITY_DESCRIPTOR;
                                        dwRevision : DWORD) : BOOL;

PROCEDURE IsValidSecurityDescriptor    (pSecurityDescriptor : PSECURITY_DESCRIPTOR) : BOOL;
PROCEDURE GetSecurityDescriptorLength  (pSecurityDescriptor : PSECURITY_DESCRIPTOR) : DWORD;
PROCEDURE GetSecurityDescriptorControl (pSecurityDescriptor : PSECURITY_DESCRIPTOR;
                                        VAR Control         : SECURITY_DESCRIPTOR_CONTROL;
                                        VAR dwRevision      : DWORD) : BOOL;

PROCEDURE SetSecurityDescriptorDacl (pSecurityDescriptor : PSECURITY_DESCRIPTOR;
                                     bDaclPresent        : BOOL;
                                     VAR [NIL] Dacl      : ACL;
                                     bDaclDefaulted      : BOOL) : BOOL;

PROCEDURE GetSecurityDescriptorDacl (pSecurityDescriptor  : PSECURITY_DESCRIPTOR;
                                     VAR bDaclPresent     : BOOL;
                                     VAR pDacl            : PACL;
                                     VAR lpbDaclDefaulted : BOOL) : BOOL;

PROCEDURE SetSecurityDescriptorSacl (pSecurityDescriptor : PSECURITY_DESCRIPTOR;
                                     bSaclPresent        : BOOL;
                                     VAR [NIL] Sacl      : ACL;
                                     bSaclDefaulted      : BOOL) : BOOL;

PROCEDURE GetSecurityDescriptorSacl (pSecurityDescriptor : PSECURITY_DESCRIPTOR;
                                     VAR lpbSaclPresent  : BOOL;
                                     VAR pSacl           : PACL;
                                     VAR bSaclDefaulted  : BOOL) : BOOL;

PROCEDURE SetSecurityDescriptorOwner (pSecurityDescriptor : PSECURITY_DESCRIPTOR;
                                      pOwner              : PSID;
                                      bOwnerDefaulted     : BOOL) : BOOL;

PROCEDURE GetSecurityDescriptorOwner (pSecurityDescriptor   : PSECURITY_DESCRIPTOR;
                                      VAR pOwner            : PSID;
                                      VAR lpbOwnerDefaulted : BOOL) : BOOL;

PROCEDURE SetSecurityDescriptorGroup (pSecurityDescriptor : PSECURITY_DESCRIPTOR;
                                      pGroup              : PSID;
                                      bGroupDefaulted     : BOOL) : BOOL;

PROCEDURE GetSecurityDescriptorGroup (pSecurityDescriptor : PSECURITY_DESCRIPTOR;
                                      VAR pGroup          : PSID;
                                      VAR bGroupDefaulted : BOOL) : BOOL;

<* IF BACKEND # "C" THEN *>
PROCEDURE CreatePrivateObjectSecurity (ParentDescriptor  : PSECURITY_DESCRIPTOR;
                                       CreatorDescriptor : PSECURITY_DESCRIPTOR;
                                       VAR NewDescriptor : PSECURITY_DESCRIPTOR;
                                       IsDirectoryObject : BOOL;
                                       Token             : HANDLE;
                                       GenericMapping    : GENERIC_MAPPING) : BOOL;
<* ELSE *>
PROCEDURE CreatePrivateObjectSecurity (ParentDescriptor  : PSECURITY_DESCRIPTOR;
                                       CreatorDescriptor : PSECURITY_DESCRIPTOR;
                                       VAR NewDescriptor : PSECURITY_DESCRIPTOR;
                                       IsDirectoryObject : BOOL;
                                       Token             : HANDLE;
                                       GenericMapping    : PGENERIC_MAPPING) : BOOL;
<* END *> (*!*)

<* IF BACKEND # "C" THEN *>
PROCEDURE SetPrivateObjectSecurity (SecurityInformation           : SECURITY_INFORMATION;
                                    ModificationDescriptor        : PSECURITY_DESCRIPTOR;
                                    VAR ObjectsSecurityDescriptor : PSECURITY_DESCRIPTOR;
                                    GenericMapping                : GENERIC_MAPPING; (*!*)
                                    Token                         : HANDLE) : BOOL;
<* ELSE *>
PROCEDURE SetPrivateObjectSecurity (SecurityInformation           : SECURITY_INFORMATION;
                                    ModificationDescriptor        : PSECURITY_DESCRIPTOR;
                                    VAR ObjectsSecurityDescriptor : PSECURITY_DESCRIPTOR;
                                    GenericMapping                : PGENERIC_MAPPING; (*!*)
                                    Token                         : HANDLE) : BOOL;
<* END *>

PROCEDURE GetPrivateObjectSecurity (ObjectDescriptor    : PSECURITY_DESCRIPTOR;
                                    SecurityInformation : SECURITY_INFORMATION;
                                    ResultantDescriptor : PSECURITY_DESCRIPTOR;
                                    DescriptorLength    : DWORD;
                                    VAR ReturnLength    : DWORD) : BOOL;

PROCEDURE DestroyPrivateObjectSecurity (VAR ObjectDescriptor : PSECURITY_DESCRIPTOR) : BOOL;

PROCEDURE MakeSelfRelativeSD (pAbsoluteSecurityDescriptor     : PSECURITY_DESCRIPTOR;
                              pSelfRelativeSecurityDescriptor : PSECURITY_DESCRIPTOR;
                              VAR dwBufferLength              : DWORD) : BOOL;

PROCEDURE MakeAbsoluteSD (pSelfRelativeSecurityDescriptor      : PSECURITY_DESCRIPTOR;
                          pAbsoluteSecurityDescriptor          : PSECURITY_DESCRIPTOR;
                          VAR dwAbsoluteSecurityDescriptorSize : DWORD;
                          VAR Dacl                             : ACL;
                          VAR dwDaclSize                       : DWORD;
                          VAR Sacl                             : ACL;
                          VAR dwSaclSize                       : DWORD;
                          pOwner                               : PSID;
                          VAR dwOwnerSize                      : DWORD;
                          pPrimaryGroup                        : PSID;
                          VAR dwPrimaryGroupSize               : DWORD) : BOOL;

PROCEDURE SetFileSecurityA (FileName            : ARRAY OF CHAR;
                            SecurityInformation : SECURITY_INFORMATION;
                            pSecurityDescriptor : PSECURITY_DESCRIPTOR) : BOOL;

PROCEDURE SetFileSecurityW (FileName            : ARRAY OF WCHAR;
                            SecurityInformation : SECURITY_INFORMATION;
                            pSecurityDescriptor : PSECURITY_DESCRIPTOR) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST SetFileSecurity = SetFileSecurityW;
<* ELSE *>
      CONST SetFileSecurity = SetFileSecurityA;
<* END *>

PROCEDURE GetFileSecurityA (lpFileName           : ARRAY OF CHAR;
                            RequestedInformation : SECURITY_INFORMATION;
                            pSecurityDescriptor  : PSECURITY_DESCRIPTOR;
                            nLength              : DWORD;
                            VAR LengthNeeded     : DWORD) : BOOL;

PROCEDURE GetFileSecurityW (lpFileName           : ARRAY OF WCHAR;
                            RequestedInformation : SECURITY_INFORMATION;
                            pSecurityDescriptor  : PSECURITY_DESCRIPTOR;
                            nLength              : DWORD;
                            VAR LengthNeeded     : DWORD) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetFileSecurity = GetFileSecurityW;
<* ELSE *>
      CONST GetFileSecurity = GetFileSecurityA;
<* END *>

PROCEDURE SetKernelObjectSecurity (Handle              : HANDLE;
                                   SecurityInformation : SECURITY_INFORMATION;
                                   SecurityDescriptor  : PSECURITY_DESCRIPTOR) : BOOL;

PROCEDURE FindFirstChangeNotificationA (lpPathName     : ARRAY OF CHAR;
                                        bWatchSubtree  : BOOL;
                                        dwNotifyFilter : FILE_NOTIFY_SET) : HANDLE;

PROCEDURE FindFirstChangeNotificationW (lpPathName     : ARRAY OF WCHAR;
                                        bWatchSubtree  : BOOL;
                                        dwNotifyFilter : FILE_NOTIFY_SET) : HANDLE;

<* IF DEFINED (UNICODE) THEN *>
      CONST FindFirstChangeNotification = FindFirstChangeNotificationW;
<* ELSE *>
      CONST FindFirstChangeNotification = FindFirstChangeNotificationA;
<* END *>

PROCEDURE FindNextChangeNotification  (hChangeHandle : HANDLE) : BOOL;
PROCEDURE FindCloseChangeNotification (hChangeHandle : HANDLE) : BOOL;

PROCEDURE ReadDirectoryChangesW (hDirectory           : HANDLE;
                                 lpBuffer             : PVOID;
                                 nBufferLength        : DWORD;
                                 bWatchSubtree        : BOOL;
                                 dwNotifyFilter       : FILE_NOTIFY_SET;
                                 VAR BytesReturned    : DWORD;
                                 VAR [NIL] Overlapped : OVERLAPPED;
                                 lpCompletionRoutine  : POVERLAPPED_COMPLETION_ROUTINE) : BOOL;

PROCEDURE VirtualLock   (lpAddress : PVOID; dwSize : DWORD) : BOOL;
PROCEDURE VirtualUnlock (lpAddress : PVOID; dwSize : DWORD) : BOOL;

PROCEDURE MapViewOfFileEx (hFileMappingObject   : HANDLE;
                           dwDesiredAccess      : ACCESS_MASK;
                           dwFileOffsetHigh     : DWORD;
                           dwFileOffsetLow      : DWORD;
                           dwNumberOfBytesToMap : DWORD;
                           lpBaseAddress        : PVOID) : PVOID;

PROCEDURE SetPriorityClass (hProcess        : HANDLE;
                            dwPriorityClass : PRIORITY_CLASS) : BOOL;

PROCEDURE GetPriorityClass (hProcess : HANDLE) : PRIORITY_CLASS;

PROCEDURE IsBadReadPtr      (lp : LPCVOID; ucb : UINT) : BOOL;
PROCEDURE IsBadWritePtr     (lp : PVOID;  ucb : UINT) : BOOL;
PROCEDURE IsBadHugeReadPtr  (lp : LPCVOID; ucb : UINT) : BOOL;
PROCEDURE IsBadHugeWritePtr (lp : PVOID; ucb : UINT) : BOOL;
PROCEDURE IsBadCodePtr      (lpfn : PROC) : BOOL;
PROCEDURE IsBadStringPtrA (lpsz : PCSTR;  ucchMax : UINT) : BOOL;
PROCEDURE IsBadStringPtrW (lpsz : PCWSTR; ucchMax : UINT) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST IsBadStringPtr = IsBadStringPtrW;
<* ELSE *>
      CONST IsBadStringPtr = IsBadStringPtrA;
<* END *>

PROCEDURE LookupAccountSidA (lpSystemName               : PCSTR;  (* NIL *)
                             Sid                        : PSID;
                             VAR Name                   : ARRAY OF CHAR;
                             VAR cbName                 : DWORD;
                             VAR ReferencedDomainName   : ARRAY OF CHAR;
                             VAR cbReferencedDomainName : DWORD;
                             VAR Use                    : SID_NAME_USE) : BOOL;

PROCEDURE LookupAccountSidW (lpSystemName               : PCWSTR; (* NIL *)
                             Sid                        : PSID;
                             VAR Name                   : ARRAY OF WCHAR;
                             VAR cbName                 : DWORD;
                             VAR ReferencedDomainName   : ARRAY OF WCHAR;
                             VAR cbReferencedDomainName : DWORD;
                             VAR Use                    : SID_NAME_USE) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST LookupAccountSid = LookupAccountSidW;
<* ELSE *>
      CONST LookupAccountSid = LookupAccountSidA;
<* END *>

PROCEDURE LookupAccountNameA (lpSystemName               : PCSTR; (*!*)
                              lpAccountName              : ARRAY OF CHAR;
                              Sid                        : PSID;
                              VAR cbSid                  : DWORD;
                              VAR ReferencedDomainName   : ARRAY OF CHAR;
                              VAR cbReferencedDomainName : DWORD;
                              VAR Use                    : SID_NAME_USE) : BOOL;

PROCEDURE LookupAccountNameW (lpSystemName               : PCWSTR; (*!*)
                              lpAccountName              : ARRAY OF WCHAR;
                              Sid                        : PSID;
                              VAR cbSid                  : DWORD;
                              VAR ReferencedDomainName   : ARRAY OF WCHAR;
                              VAR cbReferencedDomainName : DWORD;
                              VAR Use                    : SID_NAME_USE) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST LookupAccountName = LookupAccountNameW;
<* ELSE *>
      CONST LookupAccountName = LookupAccountNameA;
<* END *>

PROCEDURE LookupPrivilegeValueA (lpSystemName : ARRAY OF CHAR;
                                 lpName       : ARRAY OF CHAR;
                                 VAR Luid     : LUID)
                                                      : BOOL;

PROCEDURE LookupPrivilegeValueW (lpSystemName : ARRAY OF WCHAR;
                                 lpName       : ARRAY OF WCHAR;
                                 VAR Luid     : LUID)
                                                      : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST LookupPrivilegeValue = LookupPrivilegeValueW;
<* ELSE *>
      CONST LookupPrivilegeValue = LookupPrivilegeValueA;
<* END *>

PROCEDURE LookupPrivilegeNameA (lpSystemName : ARRAY OF CHAR;
                                VAR Luid     : LUID;
                                VAR Name     : ARRAY OF CHAR;
                                VAR cbName   : DWORD) : BOOL;

PROCEDURE LookupPrivilegeNameW (lpSystemName : ARRAY OF WCHAR;
                                VAR Luid     : LUID;
                                VAR Name     : ARRAY OF WCHAR;
                                VAR cbName   : DWORD) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST LookupPrivilegeName = LookupPrivilegeNameW;
<* ELSE *>
      CONST LookupPrivilegeName = LookupPrivilegeNameA;
<* END *>

PROCEDURE LookupPrivilegeDisplayNameA (SystemName        : PCSTR;
                                       Name              : ARRAY OF CHAR;
                                       VAR DisplayName   : ARRAY OF CHAR;
                                       VAR cbDisplayName : DWORD;
                                       VAR lpLanguageId  : DWORD) : BOOL;

PROCEDURE LookupPrivilegeDisplayNameW (SystemName        : PCWSTR;
                                       Name              : ARRAY OF WCHAR;
                                       VAR DisplayName   : ARRAY OF WCHAR;
                                       VAR cbDisplayName : DWORD;
                                       VAR lpLanguageId  : DWORD) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST LookupPrivilegeDisplayName = LookupPrivilegeDisplayNameW;
<* ELSE *>
      CONST LookupPrivilegeDisplayName = LookupPrivilegeDisplayNameA;
<* END *>


PROCEDURE AllocateLocallyUniqueId (VAR uid : LUID) : BOOL;

PROCEDURE BuildCommDCBA (Def : ARRAY OF CHAR;  VAR DCB : DCB) : BOOL;
PROCEDURE BuildCommDCBW (Def : ARRAY OF WCHAR; VAR DCB : DCB) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST BuildCommDCB = BuildCommDCBW;
<* ELSE *>
      CONST BuildCommDCB = BuildCommDCBA;
<* END *>

<* IF BACKEND # "C" THEN *>
PROCEDURE BuildCommDCBAndTimeoutsA (Def          : ARRAY OF CHAR;
                                    VAR DCB      : DCB;
                                    CommTimeouts : COMMTIMEOUTS) : BOOL;
<* ELSE *>
PROCEDURE BuildCommDCBAndTimeoutsA (Def          : ARRAY OF CHAR;
                                    VAR DCB      : DCB;
                                    CommTimeouts : PCOMMTIMEOUTS) : BOOL;
<* END *>  (*!*)

<* IF BACKEND # "C" THEN *>
PROCEDURE BuildCommDCBAndTimeoutsW (Def          : ARRAY OF WCHAR;
                                    VAR DCB      : DCB;
                                    CommTimeouts : COMMTIMEOUTS) : BOOL;
<* ELSE *>
PROCEDURE BuildCommDCBAndTimeoutsW (Def          : ARRAY OF WCHAR;
                                    VAR DCB      : DCB;
                                    CommTimeouts : PCOMMTIMEOUTS) : BOOL;
<* END *>  (*!*)

<* IF DEFINED (UNICODE) THEN *>
      CONST BuildCommDCBAndTimeouts = BuildCommDCBAndTimeoutsW;
<* ELSE *>
      CONST BuildCommDCBAndTimeouts = BuildCommDCBAndTimeoutsA;
<* END *>

PROCEDURE CommConfigDialogA (Name   : ARRAY OF CHAR;
                             hWnd   : HWND;
                             VAR CC : COMMCONFIG) : BOOL;

PROCEDURE CommConfigDialogW (Name   : ARRAY OF WCHAR;
                             hWnd   : HWND;
                             VAR CC : COMMCONFIG) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST CommConfigDialog = CommConfigDialogW;
<* ELSE *>
      CONST CommConfigDialog = CommConfigDialogA;
<* END *>

PROCEDURE GetDefaultCommConfigA (Name       : ARRAY OF CHAR;
                                 VAR CC     : COMMCONFIG;
                                 VAR dwSize : DWORD)
                                                     : BOOL;

PROCEDURE GetDefaultCommConfigW (Name       : ARRAY OF WCHAR;
                                 VAR CC     : COMMCONFIG;
                                 VAR dwSize : DWORD)
                                                     : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetDefaultCommConfig = GetDefaultCommConfigW;
<* ELSE *>
      CONST GetDefaultCommConfig = GetDefaultCommConfigA;
<* END *>

<* IF BACKEND # "C" THEN *>
PROCEDURE SetDefaultCommConfigA (Name   : ARRAY OF CHAR;
                                 CC     : COMMCONFIG;  (*!*)
                                 dwSize : DWORD)
                                                   : BOOL;
<* ELSE *>
PROCEDURE SetDefaultCommConfigA (Name   : ARRAY OF CHAR;
                                 CC     : PCOMMCONFIG;  (*!*)
                                 dwSize : DWORD)
                                                   : BOOL;
<* END *>

<* IF BACKEND # "C" THEN *>
PROCEDURE SetDefaultCommConfigW (Name   : ARRAY OF WCHAR;
                                 CC     : COMMCONFIG;  (*!*)
                                 dwSize : DWORD)
                                                   : BOOL;
<* ELSE *>
PROCEDURE SetDefaultCommConfigW (Name   : ARRAY OF WCHAR;
                                 CC     : PCOMMCONFIG;  (*!*)
                                 dwSize : DWORD)
                                                   : BOOL;
<* END *>

<* IF DEFINED (UNICODE) THEN *>
      CONST SetDefaultCommConfig = SetDefaultCommConfigW;
<* ELSE *>
      CONST SetDefaultCommConfig = SetDefaultCommConfigA;
<* END *>

CONST MAX_COMPUTERNAME_LENGTH = 15;

PROCEDURE GetComputerNameA (VAR Buffer : ARRAY OF CHAR; VAR Size : DWORD) : BOOL;
PROCEDURE GetComputerNameW (VAR Buffer : ARRAY OF WCHAR; VAR Size : DWORD) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetComputerName = GetComputerNameW;
<* ELSE *>
      CONST GetComputerName = GetComputerNameA;
<* END *>

PROCEDURE SetComputerNameA (ComputerName : ARRAY OF CHAR)  : BOOL;
PROCEDURE SetComputerNameW (ComputerName : ARRAY OF WCHAR) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST SetComputerName = SetComputerNameW;
<* ELSE *>
      CONST SetComputerName = SetComputerNameA;
<* END *>

PROCEDURE GetUserNameA (VAR Buffer : ARRAY OF CHAR;  VAR Size : DWORD) : BOOL;
PROCEDURE GetUserNameW (VAR Buffer : ARRAY OF WCHAR; VAR Size : DWORD) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetUserName = GetUserNameW;
<* ELSE *>
      CONST GetUserName = GetUserNameA;
<* END *>

(*
** Logon Support APIs
*)

TYPE LOGON_TYPE = (LOGON32_0,
                   LOGON32_1,
                   LOGON32_LOGON_INTERACTIVE, (* 2 *)
                   LOGON32_LOGON_NETWORK,     (* 3 *)
                   LOGON32_LOGON_BATCH,       (* 4 *)
                   LOGON32_LOGON_SERVICE);    (* 5 *)


TYPE LOGON_PROVIDER_TYPE = (LOGON32_PROVIDER_DEFAULT,  (* 0 *)
                            LOGON32_PROVIDER_WINNT35,  (* 1 *)
                            LOGON32_PROVIDER_WINNT40); (* 2 *)

PROCEDURE LogonUserA (lpszUsername    : ARRAY OF CHAR;
                      lpszDomain      : ARRAY OF CHAR;
                      lpszPassword    : ARRAY OF CHAR;
                      dwLogonType     : LOGON_TYPE;
                      dwLogonProvider : LOGON_PROVIDER_TYPE;
                      VAR Token       : HANDLE)
                                                : BOOL;

PROCEDURE LogonUserW (lpszUsername    : ARRAY OF WCHAR;
                      lpszDomain      : ARRAY OF WCHAR;
                      lpszPassword    : ARRAY OF WCHAR;
                      dwLogonType     : LOGON_TYPE;
                      dwLogonProvider : LOGON_PROVIDER_TYPE;
                      VAR Token       : HANDLE)
                                                : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST LogonUser = LogonUserW;
<* ELSE *>
      CONST LogonUser = LogonUserA;
<* END *>

PROCEDURE ImpersonateLoggedOnUser (hToken : HANDLE) : BOOL;

PROCEDURE CreateProcessAsUserA (hToken                 : HANDLE;
                                lpApplicationName      : PCSTR; (* IN NIL *)
                                lpCommandLine          : PCSTR; (* IN NIL *)
                                lpProcessAttributes    : PSECURITY_ATTRIBUTES;
                                lpThreadAttributes     : PSECURITY_ATTRIBUTES;
                                bInheritHandles        : BOOL;
                                dwCreationFlags        : CREATE_SET;
                                lpEnvironment          : PVOID;
                                lpCurrentDirectory     : PCSTR; (* IN NIL *)
                                VAR StartupInfo        : STARTUPINFOA; (* IN *)
                                VAR ProcessInformation : PROCESS_INFORMATION) : BOOL;

PROCEDURE CreateProcessAsUserW (hToken                 : HANDLE;
                                lpApplicationName      : PCWSTR; (* IN NIL *)
                                lpCommandLine          : PCWSTR; (* IN NIL *)
                                lpProcessAttributes    : PSECURITY_ATTRIBUTES;
                                lpThreadAttributes     : PSECURITY_ATTRIBUTES;
                                bInheritHandles        : BOOL;
                                dwCreationFlags        : CREATE_SET;
                                lpEnvironment          : PVOID;
                                lpCurrentDirectory     : PCWSTR; (* IN NIL *)
                                VAR StartupInfo        : STARTUPINFOW; (* IN *)
                                VAR ProcessInformation : PROCESS_INFORMATION) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST CreateProcessAsUser = CreateProcessAsUserW;
<* ELSE *>
      CONST CreateProcessAsUser = CreateProcessAsUserA;
<* END *>

PROCEDURE DuplicateTokenEx (hExistingToken     : HANDLE;
                            dwDesiredAccess    : ACCESS_MASK;
                            lpTokenAttributes  : PSECURITY_ATTRIBUTES;
                            ImpersonationLevel : SECURITY_IMPERSONATION_LEVEL;
                            TokenType          : TOKEN_TYPE;
                            VAR NewToken       : HANDLE)
                                                         : BOOL;

(*
** Plug-and-Play API's
*)

CONST HW_PROFILE_GUIDLEN = 39;  (* 36-characters plus NULL terminator *)
CONST MAX_PROFILE_LEN    = 80;


TYPE DOCKINFO_ENUM = (DOCKINFO__UNDOCKED,        (* 0 *)
                      DOCKINFO__DOCKED,          (* 1 *)
                      DOCKINFO__USER_SUPPLIED);  (* 2 *)

     DOCKINFO_SET = SET OF DOCKINFO_ENUM;

CONST DOCKINFO_UNDOCKED      = DOCKINFO_SET {DOCKINFO__UNDOCKED};      (* 0x1 *)
      DOCKINFO_DOCKED        = DOCKINFO_SET {DOCKINFO__DOCKED};        (* 0x2 *)
      DOCKINFO_USER_SUPPLIED = DOCKINFO_SET {DOCKINFO__USER_SUPPLIED}; (* 0x4 *)

      DOCKINFO_USER_UNDOCKED = DOCKINFO_USER_SUPPLIED + DOCKINFO_UNDOCKED;
      DOCKINFO_USER_DOCKED   = DOCKINFO_USER_SUPPLIED + DOCKINFO_DOCKED;

TYPE HW_PROFILE_INFOA = RECORD
                               dwDockInfo      : DOCKINFO_SET;
                               szHwProfileGuid : ARRAY [0..HW_PROFILE_GUIDLEN-1] OF CHAR;
                               szHwProfileName : ARRAY [0..MAX_PROFILE_LEN-1] OF CHAR;
                        END;
    PHW_PROFILE_INFOA = POINTER TO HW_PROFILE_INFOA;

     HW_PROFILE_INFOW = RECORD
                               dwDockInfo      : DOCKINFO_SET;
                               szHwProfileGuid : ARRAY [0..HW_PROFILE_GUIDLEN-1] OF WCHAR;
                               szHwProfileName : ARRAY [0..MAX_PROFILE_LEN-1] OF WCHAR;
                        END;
    PHW_PROFILE_INFOW = POINTER TO HW_PROFILE_INFOW;

<* IF DEFINED (UNICODE) THEN *>
      TYPE  HW_PROFILE_INFO =  HW_PROFILE_INFOW;
           PHW_PROFILE_INFO = PHW_PROFILE_INFOW;
<* ELSE *>
      TYPE  HW_PROFILE_INFO =  HW_PROFILE_INFOA;
           PHW_PROFILE_INFO = PHW_PROFILE_INFOA;
<* END *>

PROCEDURE GetCurrentHwProfileA (VAR HwProfileInfo : HW_PROFILE_INFOA) : BOOL;
PROCEDURE GetCurrentHwProfileW (VAR HwProfileInfo : HW_PROFILE_INFOW) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetCurrentHwProfile = GetCurrentHwProfileW;
<* ELSE *>
      CONST GetCurrentHwProfile = GetCurrentHwProfileA;
<* END *>

(*
** Performance counter API's
*)

PROCEDURE QueryPerformanceCounter   (VAR PerformanceCount : LARGE_INTEGER) : BOOL;
PROCEDURE QueryPerformanceFrequency (VAR Frequency : LARGE_INTEGER) : BOOL;

(*
** RtlVerifyVersionInfo() os product type values
*)

CONST VER_NT_WORKSTATION       = 1;
      VER_NT_DOMAIN_CONTROLLER = 2;
      VER_NT_SERVER            = 3;

(*
** dwPlatformId defines:
*)

TYPE VER_PLATFORM_TYPE = (VER_PLATFORM_WIN32s,        (* 0 *)
                          VER_PLATFORM_WIN32_WINDOWS, (* 1 *)
                          VER_PLATFORM_WIN32_NT);     (* 2 *)

TYPE OSVERSIONINFOA = RECORD
                             dwOSVersionInfoSize : DWORD;
                             dwMajorVersion      : DWORD;
                             dwMinorVersion      : DWORD;
                             dwBuildNumber       : DWORD;
                             dwPlatformId        : VER_PLATFORM_TYPE;
                             szCSDVersion        : ARRAY [0..127] OF CHAR; (* Maintenance string for PSS usage *)
                      END;
    POSVERSIONINFOA = POINTER TO OSVERSIONINFOA;

TYPE OSVERSIONINFOW = RECORD
                             dwOSVersionInfoSize : DWORD;
                             dwMajorVersion      : DWORD;
                             dwMinorVersion      : DWORD;
                             dwBuildNumber       : DWORD;
                             dwPlatformId        : VER_PLATFORM_TYPE;
                             szCSDVersion        : ARRAY [0..127] OF WCHAR; (* Maintenance string for PSS usage *)
                      END;
    POSVERSIONINFOW = POINTER TO OSVERSIONINFOW;

<* IF DEFINED (UNICODE) THEN *>
       TYPE OSVERSIONINFO =  OSVERSIONINFOW;
           POSVERSIONINFO = POSVERSIONINFOW;
<* ELSE *>
       TYPE OSVERSIONINFO =  OSVERSIONINFOA;
           POSVERSIONINFO = POSVERSIONINFOA;
<* END *>

TYPE OSVERSIONINFOEXA = RECORD
                             dwOSVersionInfoSize : DWORD;
                             dwMajorVersion      : DWORD;
                             dwMinorVersion      : DWORD;
                             dwBuildNumber       : DWORD;
                             dwPlatformId        : VER_PLATFORM_TYPE;
                             szCSDVersion        : ARRAY [0..127] OF CHAR; (* Maintenance string for PSS usage *)
                             wServicePackMajor   : WORD;
                             wServicePackMinor   : WORD;
                             wSuiteMask          : WORD;
                             wProductType        : BYTE;
                             wReserved           : BYTE;
                      END;
    POSVERSIONINFOEXA = POINTER TO OSVERSIONINFOEXA;

TYPE OSVERSIONINFOEXW = RECORD
                             dwOSVersionInfoSize : DWORD;
                             dwMajorVersion      : DWORD;
                             dwMinorVersion      : DWORD;
                             dwBuildNumber       : DWORD;
                             dwPlatformId        : VER_PLATFORM_TYPE;
                             szCSDVersion        : ARRAY [0..127] OF WCHAR; (* Maintenance string for PSS usage *)
                             wServicePackMajor   : WORD;
                             wServicePackMinor   : WORD;
                             wSuiteMask          : WORD;
                             wProductType        : BYTE;
                             wReserved           : BYTE;
                      END;
    POSVERSIONINFOEXW = POINTER TO OSVERSIONINFOEXW;

<* IF DEFINED (UNICODE) THEN *>
       TYPE OSVERSIONINFOEX =  OSVERSIONINFOEXW;
           POSVERSIONINFOEX = POSVERSIONINFOEXW;
<* ELSE *>
       TYPE OSVERSIONINFOEX =  OSVERSIONINFOEXA;
           POSVERSIONINFOEX = POSVERSIONINFOEXA;
<* END *>

PROCEDURE GetVersionExA (VAR VersionInformation : OSVERSIONINFOA) : BOOL;
PROCEDURE GetVersionExW (VAR VersionInformation : OSVERSIONINFOW) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetVersionEx = GetVersionExW;
<* ELSE *>
      CONST GetVersionEx = GetVersionExA;
<* END *>

(* DOS and OS/2 Compatible Error Code definitions returned by the Win32 Base
** API functions.
*)

(* Abnormal termination codes *)

CONST TC_NORMAL  = 0;
      TC_HARDERR = 1;
      TC_GP_TRAP = 2;
      TC_SIGNAL  = 3;

(*
** Power Management APIs
*)

TYPE AC_LINE_TYPE = INT8;

CONST AC_LINE_OFFLINE               = VAL (AC_LINE_TYPE,  0);
      AC_LINE_ONLINE                = VAL (AC_LINE_TYPE,  1);
      AC_LINE_BACKUP_POWER          = VAL (AC_LINE_TYPE,  2);
      AC_LINE_UNKNOWN               = VAL (AC_LINE_TYPE, -1);

TYPE BATTERY_FLAG_ENUM = (BATTERY_FLAG__HIGH,        (* 0 *)
                          BATTERY_FLAG__LOW,         (* 1 *)
                          BATTERY_FLAG__CRITICAL,    (* 2 *)
                          BATTERY_FLAG__CHARGING,    (* 3 *)
                          BATTERY_FLAG__4,
                          BATTERY_FLAG__5,
                          BATTERY_FLAG__6,
                          BATTERY_FLAG__NO_BATTERY); (* 7 *)

<* PUSH *> <* SETSIZE = "1" *>

TYPE BATTERY_FLAG_SET = SET OF BATTERY_FLAG_ENUM;

CONST BATTERY_FLAG_HIGH       = BATTERY_FLAG_SET {BATTERY_FLAG__HIGH};       (* 01h *)
      BATTERY_FLAG_LOW        = BATTERY_FLAG_SET {BATTERY_FLAG__LOW};        (* 02h *)
      BATTERY_FLAG_CRITICAL   = BATTERY_FLAG_SET {BATTERY_FLAG__CRITICAL};   (* 04h *)
      BATTERY_FLAG_CHARGING   = BATTERY_FLAG_SET {BATTERY_FLAG__CHARGING};   (* 08h *)
      BATTERY_FLAG_NO_BATTERY = BATTERY_FLAG_SET {BATTERY_FLAG__NO_BATTERY}; (* 80h *)

      BATTERY_FLAG_UNKNOWN    = BATTERY_FLAG_SET {MIN (BATTERY_FLAG_ENUM)..
                                                  MAX (BATTERY_FLAG_ENUM)};  (* 0FFh *)

<* POP *>

      BATTERY_PERCENTAGE_UNKNOWN    = 0FFh;

      BATTERY_LIFE_UNKNOWN          = 0FFFFFFFFh;

TYPE SYSTEM_POWER_STATUS = RECORD
                                  ACLineStatus        : AC_LINE_TYPE;
                                  BatteryFlag         : BATTERY_FLAG_SET;
                                  BatteryLifePercent  : BYTE;
                                  Reserved1           : BYTE;
                                  BatteryLifeTime     : DWORD;
                                  BatteryFullLifeTime : DWORD;
                           END;
    PSYSTEM_POWER_STATUS = POINTER TO SYSTEM_POWER_STATUS;

PROCEDURE GetSystemPowerStatus (VAR SystemPowerStatus : SYSTEM_POWER_STATUS) : BOOL;
PROCEDURE SetSystemPowerState  (fSuspend : BOOL; fForce : BOOL) : BOOL;


(*************************************************************)
(*                                                           *)
(*      Win Certificate API and Structures                   *)
(*                                                           *)
(*************************************************************)

(*
** Structures
*)

(*
** Possible certificate types are specified by the following values
*)

<* PUSH *> <* ENUMSIZE = "2" *>

TYPE WIN_CERT_TYPE  = (WIN_CERT_TYPE_0,
                       WIN_CERT_TYPE_X509,             (* 0x0001 bCertificate contains an X.509 Certificate *)
                       WIN_CERT_TYPE_PKCS_SIGNED_DATA, (* 0x0002 bCertificate contains a PKCS SignedData structure *)
                       WIN_CERT_TYPE_RESERVED_1);      (* 0x0003 Reserved *)
<* POP *>

TYPE WIN_CERTIFICATE = RECORD
                              dwLength         : DWORD;
                              wRevision        : WORD;
                              wCertificateType : WIN_CERT_TYPE;
                              bCertificate     : ARRAY [0..0] OF BYTE;
                       END;

    PWIN_CERTIFICATE = POINTER TO WIN_CERTIFICATE;

(*
** Currently, the only defined certificate revision is WIN_CERT_REVISION_1_0
*)

CONST WIN_CERT_REVISION_1_0  = 0100h;

(*
** API
*)

PROCEDURE WinSubmitCertificate (VAR Certificate : WIN_CERTIFICATE) : BOOL;


(*************************************************************)
(*                                                           *)
(*             Trust API and Structures                      *)
(*                                                           *)
(*************************************************************)

PROCEDURE WinVerifyTrust (hwnd         : HWND;
                          VAR ActionID : GUID;
                          ActionData   : PVOID) : LONG;

PROCEDURE WinLoadTrustProvider (VAR ActionID : GUID) : BOOL;


(*************************************************************)
(*                                                           *)
(*             Common Trust API Data Structures              *)
(*                                                           *)
(*************************************************************)


(*
** Data type commonly used in ActionData structures
*)

TYPE WIN_TRUST_SUBJECT = PVOID;

(*
** Two commonly used ActionData structures
*)

TYPE WIN_TRUST_ACTDATA_CONTEXT_WITH_SUBJECT =
     RECORD
          hClientToken : HANDLE;
          SubjectType  : PGUID;
          Subject      : WIN_TRUST_SUBJECT;
     END;
     PWIN_TRUST_ACTDATA_CONTEXT_WITH_SUBJECT = POINTER TO WIN_TRUST_ACTDATA_CONTEXT_WITH_SUBJECT;

TYPE WIN_TRUST_ACTDATA_SUBJECT_ONLY =
     RECORD
            SubjectType : PGUID;
            Subject     : WIN_TRUST_SUBJECT;
     END;
     PWIN_TRUST_ACTDATA_SUBJECT_ONLY = POINTER TO WIN_TRUST_ACTDATA_SUBJECT_ONLY;


(*****************************************************************)
(*                                                               *)
(*      SUBJECT FORM DEFINITIONS                                 *)
(*                                                               *)
(*****************************************************************)

(*****************************************************************)
(*                                                               *)
(* Currently defined Subject Type Identifiers.  All of the below *)
(* use the WIN_TRUST_SUBJECT_FILE subject form, defined below.   *)
(*                                                               *)
(*****************************************************************)

(* RawFile == 959dc450-8d9e-11cf-8736-00aa00a485eb *)

CONST WIN_TRUST_SUBJTYPE_RAW_FILE =
      GUID {
            959dc450h,
            8d9eh,
            11cfh,
            BYTEARRAY8 {87h, 36h, 00h, 0aah, 00h, 0a4h, 085h, 0ebh}
      };

(* PeImage == 43c9a1e0-8da0-11cf-8736-00aa00a485eb *)

CONST WIN_TRUST_SUBJTYPE_PE_IMAGE =
      GUID {
            43c9a1e0h,
            8da0h,
            11cfh,
            BYTEARRAY8 {87h, 36h, 00h, 0aah, 00h, 0a4h, 085h, 0ebh}
      };

(* JavaClass = 08ad3990-8da1-11cf-8736-00aa00a485eb *)

CONST WIN_TRUST_SUBJTYPE_JAVA_CLASS =
      GUID {
            08ad3990h,
            8da1h,
            11cfh,
            BYTEARRAY8 {87h, 36h, 00h, 0aah, 00h, 0a4h, 085h, 0ebh}
      };

(* Cabinet = d17c5374-a392-11cf-9df5-00aa00c184e0 *)

CONST WIN_TRUST_SUBJTYPE_CABINET =
      GUID {
            0d17c5374h,
            0a392h,
            011cfh,
            BYTEARRAY8 {9dh, 0f5h, 0, 0aah, 0, 0c1h, 084h, 0e0h}
      };

(*
** Associated Subject Data Structure:
*)

TYPE WIN_TRUST_SUBJECT_FILE = RECORD
                                     hFile  : HANDLE;
                                     lpPath : PCWSTR;
                              END;
    PWIN_TRUST_SUBJECT_FILE = POINTER TO WIN_TRUST_SUBJECT_FILE;


(******************************************************************)
(*                                                                *)
(* The following subject types use the                            *)
(* WIN_TRUST_SUBJECT_FILE_AND_DISPLAY subject type, defined       *)
(* below.                                                         *)
(*                                                                *)
(******************************************************************)

CONST WIN_TRUST_SUBJTYPE_RAW_FILEEX =
      GUID {
            6f458111h,
            0c2f1h,
            011cfh,
            BYTEARRAY8 {8ah, 69h, 0, 0aah, 0, 6ch, 37h, 6}
      };

CONST WIN_TRUST_SUBJTYPE_PE_IMAGEEX =
      GUID {
            6f458110h,
            0c2f1h,
            011cfh,
            BYTEARRAY8 {8ah, 69h, 0, 0aah, 0, 6ch, 37h, 6}
      };

CONST WIN_TRUST_SUBJTYPE_JAVA_CLASSEX =
      GUID {
            6f458113h,
            0c2f1h,
            011cfh,
            BYTEARRAY8 {8ah, 69h, 0, 0aah, 0, 6ch, 37h, 6}
      };

CONST WIN_TRUST_SUBJTYPE_CABINETEX =
      GUID {
            6f458114h,
            0c2f1h,
            011cfh,
            BYTEARRAY8 {8ah, 69h, 0, 0aah, 0, 6ch, 37h, 6}
      };

(*
** Associated Subject Data Structure:
*)

TYPE WIN_TRUST_SUBJECT_FILE_AND_DISPLAY =
     RECORD
            hFile         : HANDLE;  (* handle to the open file if you got it *)
            lpPath        : PCWSTR;  (* the path to open if you don't *)
            lpDisplayName : PCWSTR;  (* (optional) display name to show to user
                                        in place of path
                                     *)
     END;
     PWIN_TRUST_SUBJECT_FILE_AND_DISPLAY = POINTER TO WIN_TRUST_SUBJECT_FILE_AND_DISPLAY;

(******************************************************************)
(*                                                                *)
(* Other subject types:                                           *)
(*                                                                *)
(******************************************************************)

(* OleStorage == c257e740-8da0-11cf-8736-00aa00a485eb *)

CONST WIN_TRUST_SUBJTYPE_OLE_STORAGE =
      GUID {
            0c257e740h,
            08da0h,
            11cfh,
            BYTEARRAY8 {087h, 36h, 0, 0aah, 0, 0a4h, 85h, 0ebh}
      };


(******************************************************************)
(*                                                                *)
(*      TRUST PROVIDER SPECIFIC DEFINITIONS                       *)
(*                                                                *)
(*                                                                *)
(*      Each trust provider will have the following               *)
(*      sections defined:                                         *)
(*                                                                *)
(*      Actions - What actions are supported by the trust         *)
(*          provider.                                             *)
(*                                                                *)
(*      SubjectForms - Subjects that may be evaluated by this     *)
(*          trust provider.                                       *)
(*                                                                *)
(*                     and                                        *)
(*                                                                *)
(*      Data structures to support the subject forms.             *)
(*                                                                *)
(*                                                                *)
(******************************************************************)


(******************************************************************)
(*                                                                *)
(*             Software Publisher Trust Provider                  *)
(*                                                                *)
(******************************************************************)

(*
** Actions:
*)

(* TrustedPublisher == 66426730-8da1-11cf-8736-00aa00a485eb *)

CONST WIN_SPUB_ACTION_TRUSTED_PUBLISHER =
      GUID {
            66426730h,
            8da1h,
            11cfh,
            BYTEARRAY8 {87h, 36h, 0, 0aah, 0, 0a4h, 085h, 0ebh}
      };

(* NtActivateImage == 8bc96b00-8da1-11cf-8736-00aa00a485eb *)

CONST WIN_SPUB_ACTION_NT_ACTIVATE_IMAGE =
      GUID {
            8bc96b00h,
            8da1h,
            11cfh,
            BYTEARRAY8 {87h, 36h, 0, 0aah, 0, 0a4h, 085h, 0ebh}
      };

(* PublishedSoftware == 64b9d180-8da2-11cf-8736-00aa00a485eb *)

CONST WIN_SPUB_ACTION_PUBLISHED_SOFTWARE =
      GUID {
            64b9d180h,
            8da2h,
            11cfh,
            BYTEARRAY8 {87h, 36h, 0, 0aah, 0, 0a4h, 085h, 0ebh}
      };

(*
** Data Structures:
**
** WIN_SPUB_ACTION_TRUSTED_PUBLISHER:
**
**      Uses WIN_SPUB_TRUSTED_PUBLISHER_DATA
**
** WIN_SPUB_ACTION_NT_ACTIVATE_IMAGE:
**
**      Uses WIN_TRUST_ACTDATA_CONTEXT_WITH_SUBJECT
**
** WIN_SPUB_ACTION_PUBLISHED_SOFTWARE:
**
**      Uses WIN_TRUST_ACTDATA_CONTEXT_WITH_SUBJECT
*)

TYPE WIN_SPUB_TRUSTED_PUBLISHER_DATA =
     RECORD
            hClientToken  : HANDLE;
            lpCertificate : PWIN_CERTIFICATE;
     END;
     PWIN_SPUB_TRUSTED_PUBLISHER_DATA = POINTER TO WIN_SPUB_TRUSTED_PUBLISHER_DATA;


END WinBase.
